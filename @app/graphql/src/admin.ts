/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A set of key/value pairs, keys are strings, values may be a string or null. Exposed as a JSON object. */
  KeyValueHash: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};

export type AuthenticateInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
};

/** All input for the create `EventCategory` mutation. */
export type CreateEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventCategory` to be created by this mutation. */
  eventCategory: EventCategoryInput;
};

/** The output of our create `EventCategory` mutation. */
export type CreateEventCategoryPayload = {
  __typename?: 'CreateEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategory` that was created by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventCategory` mutation. */
export type CreateEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the create `EventTemplate` mutation. */
export type CreateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTemplate` to be created by this mutation. */
  eventTemplate: EventTemplateInput;
};

/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayload = {
  __typename?: 'CreateEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was created by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Group` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the create `Member` mutation. */
export type CreateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` to be created by this mutation. */
  member: MemberInput;
};

/** The output of our create `Member` mutation. */
export type CreateMemberPayload = {
  __typename?: 'CreateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was created by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Member` mutation. */
export type CreateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `createUploadUrl` mutation. */
export type CreateUploadUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * You must provide the content type (or MIME type) of the content you intend
   * to upload. For further information about content types, see
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
   */
  contentType: Scalars['String'];
};

/** The output of our `createUploadUrl` mutation. */
export type CreateUploadUrlPayload = {
  __typename?: 'CreateUploadUrlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  formData: Scalars['String'];
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Upload content to this signed URL. */
  uploadUrl: Scalars['String'];
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
};

/** All input for the `deleteEventCategory` mutation. */
export type DeleteEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventCategory` mutation. */
export type DeleteEventCategoryPayload = {
  __typename?: 'DeleteEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventCategoryNodeId: Maybe<Scalars['ID']>;
  /** The `EventCategory` that was deleted by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventCategory` mutation. */
export type DeleteEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventNodeId: Maybe<Scalars['ID']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteEventTemplate` mutation. */
export type DeleteEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayload = {
  __typename?: 'DeleteEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTemplateNodeId: Maybe<Scalars['ID']>;
  /** The `EventTemplate` that was deleted by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteMember` mutation. */
export type DeleteMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Member` mutation. */
export type DeleteMemberPayload = {
  __typename?: 'DeleteMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedMemberNodeId: Maybe<Scalars['ID']>;
  /** The `Member` that was deleted by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Member` mutation. */
export type DeleteMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

export type Event = {
  __typename?: 'Event';
  categoryId: Scalars['BigInt'];
  description: Scalars['KeyValueHash'];
  endsAt: Scalars['Datetime'];
  id: Scalars['BigInt'];
  slug: Maybe<Scalars['KeyValueHash']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  title: Scalars['KeyValueHash'];
  venue: Scalars['KeyValueHash'];
};

/** A connection to a list of `EventCategory` values. */
export type EventCategoriesConnection = {
  __typename?: 'EventCategoriesConnection';
  /** A list of edges which contains the `EventCategory` and cursor to aid in pagination. */
  edges: Array<EventCategoriesEdge>;
  /** A list of `EventCategory` objects. */
  nodes: Array<EventCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventCategory` edge in the connection. */
export type EventCategoriesEdge = {
  __typename?: 'EventCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventCategory` at the end of the edge. */
  node: EventCategory;
};

/** Methods to use when ordering `EventCategory`. */
export enum EventCategoriesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export type EventCategory = {
  __typename?: 'EventCategory';
  id: Scalars['BigInt'];
  title: Scalars['KeyValueHash'];
};

/**
 * A condition to be used against `EventCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['KeyValueHash']>;
};

/** A filter to be used against `EventCategory` object types. All fields are combined with a logical ‘and.’ */
export type EventCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventCategoryFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventCategoryFilter>>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<KeyValueHashFilter>;
};

/** An input for mutations affecting `EventCategory` */
export type EventCategoryInput = {
  title: Scalars['KeyValueHash'];
};

/** Represents an update to a `EventCategory`. Fields that are set will be updated. */
export type EventCategoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['KeyValueHash']>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `endsAt` field. */
  endsAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `special` field. */
  special?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startsAt` field. */
  startsAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['KeyValueHash']>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `endsAt` field. */
  endsAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `special` field. */
  special?: Maybe<BooleanFilter>;
  /** Filter by the object’s `startsAt` field. */
  startsAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<KeyValueHashFilter>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  categoryId: Scalars['BigInt'];
  description: Scalars['KeyValueHash'];
  endsAt: Scalars['Datetime'];
  slug?: Maybe<Scalars['KeyValueHash']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  title: Scalars['KeyValueHash'];
  venue: Scalars['KeyValueHash'];
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  categoryId?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['KeyValueHash']>;
  endsAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['BigInt']>;
  slug?: Maybe<Scalars['KeyValueHash']>;
  special?: Maybe<Scalars['Boolean']>;
  startsAt?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['KeyValueHash']>;
  venue?: Maybe<Scalars['KeyValueHash']>;
};

export type EventTemplate = {
  __typename?: 'EventTemplate';
  categoryId: Scalars['BigInt'];
  description: Scalars['KeyValueHash'];
  id: Scalars['BigInt'];
  title: Scalars['KeyValueHash'];
  venue: Scalars['KeyValueHash'];
};

/**
 * A condition to be used against `EventTemplate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTemplateCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['KeyValueHash']>;
};

/** A filter to be used against `EventTemplate` object types. All fields are combined with a logical ‘and.’ */
export type EventTemplateFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventTemplateFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventTemplateFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventTemplateFilter>>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<KeyValueHashFilter>;
};

/** An input for mutations affecting `EventTemplate` */
export type EventTemplateInput = {
  categoryId: Scalars['BigInt'];
  description: Scalars['KeyValueHash'];
  title: Scalars['KeyValueHash'];
  venue: Scalars['KeyValueHash'];
};

/** Represents an update to a `EventTemplate`. Fields that are set will be updated. */
export type EventTemplatePatch = {
  categoryId?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['KeyValueHash']>;
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['KeyValueHash']>;
  venue?: Maybe<Scalars['KeyValueHash']>;
};

/** A connection to a list of `EventTemplate` values. */
export type EventTemplatesConnection = {
  __typename?: 'EventTemplatesConnection';
  /** A list of edges which contains the `EventTemplate` and cursor to aid in pagination. */
  edges: Array<EventTemplatesEdge>;
  /** A list of `EventTemplate` objects. */
  nodes: Array<EventTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTemplate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTemplate` edge in the connection. */
export type EventTemplatesEdge = {
  __typename?: 'EventTemplatesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTemplate` at the end of the edge. */
  node: EventTemplate;
};

/** Methods to use when ordering `EventTemplate`. */
export enum EventTemplatesOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EndsAtAsc = 'ENDS_AT_ASC',
  EndsAtDesc = 'ENDS_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  SpecialAsc = 'SPECIAL_ASC',
  SpecialDesc = 'SPECIAL_DESC',
  StartsAtAsc = 'STARTS_AT_ASC',
  StartsAtDesc = 'STARTS_AT_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

export type Group = {
  __typename?: 'Group';
  description: Scalars['KeyValueHash'];
  id: Scalars['BigInt'];
  imageFile: Scalars['String'];
  slug: Maybe<Scalars['KeyValueHash']>;
  title: Scalars['KeyValueHash'];
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageFile` field. */
  imageFile?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['KeyValueHash']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['KeyValueHash']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupFilter>>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageFile` field. */
  imageFile?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<GroupFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<KeyValueHashFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<KeyValueHashFilter>;
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  description: Scalars['KeyValueHash'];
  imageFile: Scalars['String'];
  slug?: Maybe<Scalars['KeyValueHash']>;
  title: Scalars['KeyValueHash'];
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  description?: Maybe<Scalars['KeyValueHash']>;
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['KeyValueHash']>;
  title?: Maybe<Scalars['KeyValueHash']>;
};

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageFileAsc = 'IMAGE_FILE_ASC',
  ImageFileDesc = 'IMAGE_FILE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}


/** A filter to be used against KeyValueHash fields. All fields are combined with a logical ‘and.’ */
export type KeyValueHashFilter = {
  /** Contained by the specified KeyValueHash. */
  containedBy?: Maybe<Scalars['KeyValueHash']>;
  /** Contains the specified KeyValueHash. */
  contains?: Maybe<Scalars['KeyValueHash']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: Maybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: Maybe<Array<Scalars['String']>>;
  /** Contains the specified key. */
  containsKey?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['KeyValueHash']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['KeyValueHash']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['KeyValueHash']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['KeyValueHash']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['KeyValueHash']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['KeyValueHash']>>;
};

export type Member = {
  __typename?: 'Member';
  id: Scalars['UUID'];
  isActive: Maybe<Scalars['Boolean']>;
  name: Maybe<Scalars['String']>;
  userRole: Maybe<Scalars['String']>;
  username: Maybe<Scalars['String']>;
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Member` object types. All fields are combined with a logical ‘and.’ */
export type MemberFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MemberFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<MemberFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MemberFilter>>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
};

/** An input for mutations affecting `Member` */
export type MemberInput = {
  id: Scalars['UUID'];
  isActive?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** Represents an update to a `Member`. Fields that are set will be updated. */
export type MemberPatch = {
  id?: Maybe<Scalars['UUID']>;
  isActive?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  authenticate: Scalars['String'];
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `EventCategory`. */
  createEventCategory: Maybe<CreateEventCategoryPayload>;
  /** Creates a single `EventTemplate`. */
  createEventTemplate: Maybe<CreateEventTemplatePayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `Member`. */
  createMember: Maybe<CreateMemberPayload>;
  /** Get a signed URL for uploading files. It will expire in 5 minutes. */
  createUploadUrl: Maybe<CreateUploadUrlPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `EventCategory` using a unique key. */
  deleteEventCategory: Maybe<DeleteEventCategoryPayload>;
  /** Deletes a single `EventTemplate` using a unique key. */
  deleteEventTemplate: Maybe<DeleteEventTemplatePayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMember: Maybe<DeleteMemberPayload>;
  logout: Maybe<Scalars['Boolean']>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `EventCategory` using a unique key and a patch. */
  updateEventCategory: Maybe<UpdateEventCategoryPayload>;
  /** Updates a single `EventTemplate` using a unique key and a patch. */
  updateEventTemplate: Maybe<UpdateEventTemplatePayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMember: Maybe<UpdateMemberPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAuthenticateArgs = {
  input: AuthenticateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventCategoryArgs = {
  input: CreateEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTemplateArgs = {
  input: CreateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMemberArgs = {
  input: CreateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUploadUrlArgs = {
  input: CreateUploadUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventCategoryArgs = {
  input: DeleteEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTemplateArgs = {
  input: DeleteEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberArgs = {
  input: DeleteMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventCategoryArgs = {
  input: UpdateEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTemplateArgs = {
  input: UpdateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  currentMember: Maybe<Member>;
  event: Maybe<Event>;
  /** Reads and enables pagination through a set of `EventCategory`. */
  eventCategories: Maybe<EventCategoriesConnection>;
  eventCategory: Maybe<EventCategory>;
  eventTemplate: Maybe<EventTemplate>;
  /** Reads and enables pagination through a set of `EventTemplate`. */
  eventTemplates: Maybe<EventTemplatesConnection>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  group: Maybe<Group>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: Maybe<GroupsConnection>;
  member: Maybe<Member>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoriesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCategoryCondition>;
  filter?: Maybe<EventCategoryFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplatesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateCondition>;
  filter?: Maybe<EventTemplateFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MemberCondition>;
  filter?: Maybe<MemberFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
};


/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['UUID']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['UUID']>>;
};

/** All input for the `updateEventCategory` mutation. */
export type UpdateEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventCategory` being updated. */
  patch: EventCategoryPatch;
};

/** The output of our update `EventCategory` mutation. */
export type UpdateEventCategoryPayload = {
  __typename?: 'UpdateEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategory` that was updated by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventCategory` mutation. */
export type UpdateEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `updateEventTemplate` mutation. */
export type UpdateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventTemplate` being updated. */
  patch: EventTemplatePatch;
};

/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayload = {
  __typename?: 'UpdateEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was updated by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateMember` mutation. */
export type UpdateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
};

/** The output of our update `Member` mutation. */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was updated by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Member` mutation. */
export type UpdateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

export type AuthenticateMutationVariables = Exact<{
  username: Scalars['String'];
  password: Scalars['String'];
}>;


export type AuthenticateMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'authenticate'>
);

export type GetMeQueryVariables = Exact<{ [key: string]: never; }>;


export type GetMeQuery = (
  { __typename?: 'Query' }
  & { currentMember: Maybe<(
    { __typename?: 'Member' }
    & Pick<Member, 'name' | 'id' | 'userRole'>
  )> }
);

export type GetUploadUrlMutationVariables = Exact<{
  contentType: Scalars['String'];
}>;


export type GetUploadUrlMutation = (
  { __typename?: 'Mutation' }
  & { createUploadUrl: Maybe<(
    { __typename?: 'CreateUploadUrlPayload' }
    & Pick<CreateUploadUrlPayload, 'uploadUrl' | 'formData'>
  )> }
);

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'logout'>
);


export const AuthenticateDocument = gql`
    mutation Authenticate($username: String!, $password: String!) {
  authenticate(input: {username: $username, password: $password})
}
    ` as unknown as DocumentNode<AuthenticateMutation, AuthenticateMutationVariables>;
export const GetMeDocument = gql`
    query GetMe {
  currentMember {
    name
    id
    userRole
  }
}
    ` as unknown as DocumentNode<GetMeQuery, GetMeQueryVariables>;
export const GetUploadUrlDocument = gql`
    mutation GetUploadUrl($contentType: String!) {
  createUploadUrl(input: {contentType: $contentType}) {
    uploadUrl
    formData
  }
}
    ` as unknown as DocumentNode<GetUploadUrlMutation, GetUploadUrlMutationVariables>;
export const LogoutDocument = gql`
    mutation Logout {
  logout
}
    ` as unknown as DocumentNode<LogoutMutation, LogoutMutationVariables>;