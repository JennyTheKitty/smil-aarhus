/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};

export type AuthenticateInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the create `EventTag` mutation. */
export type CreateEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTag` to be created by this mutation. */
  eventTag: EventTagInput;
};

/** The output of our create `EventTag` mutation. */
export type CreateEventTagPayload = {
  __typename?: 'CreateEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTag` that was created by this mutation. */
  eventTag: Maybe<EventTag>;
  /** An edge for our `EventTag`. May be used by Relay 1. */
  eventTagEdge: Maybe<EventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTag` mutation. */
export type CreateEventTagPayloadEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};

/** All input for the create `EventTagTr` mutation. */
export type CreateEventTagTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTagTr` to be created by this mutation. */
  eventTagTr: EventTagTrInput;
};

/** The output of our create `EventTagTr` mutation. */
export type CreateEventTagTrPayload = {
  __typename?: 'CreateEventTagTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTagTr` that was created by this mutation. */
  eventTagTr: Maybe<EventTagTr>;
  /** An edge for our `EventTagTr`. May be used by Relay 1. */
  eventTagTrEdge: Maybe<EventTagTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventTagTr`. */
  tag: Maybe<EventTag>;
};


/** The output of our create `EventTagTr` mutation. */
export type CreateEventTagTrPayloadEventTagTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};

/** All input for the create `EventTemplate` mutation. */
export type CreateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTemplate` to be created by this mutation. */
  eventTemplate: EventTemplateInput;
};

/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayload = {
  __typename?: 'CreateEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was created by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTemplateTr` to be created by this mutation. */
  eventTemplateTr: EventTemplateTrInput;
};

/** The output of our create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrPayload = {
  __typename?: 'CreateEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was created by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the create `EventTr` mutation. */
export type CreateEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTr` to be created by this mutation. */
  eventTr: EventTrInput;
};

/** The output of our create `EventTr` mutation. */
export type CreateEventTrPayload = {
  __typename?: 'CreateEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was created by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTr` mutation. */
export type CreateEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventViaEventTag` to be created by this mutation. */
  eventViaEventTag: EventViaEventTagInput;
};

/** The output of our create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagPayload = {
  __typename?: 'CreateEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was created by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the create `EventViaGroup` mutation. */
export type CreateEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventViaGroup` to be created by this mutation. */
  eventViaGroup: EventViaGroupInput;
};

/** The output of our create `EventViaGroup` mutation. */
export type CreateEventViaGroupPayload = {
  __typename?: 'CreateEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was created by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventViaGroup` mutation. */
export type CreateEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Group` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the create `GroupTr` mutation. */
export type CreateGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GroupTr` to be created by this mutation. */
  groupTr: GroupTrInput;
};

/** The output of our create `GroupTr` mutation. */
export type CreateGroupTrPayload = {
  __typename?: 'CreateGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was created by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GroupTr` mutation. */
export type CreateGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the create `Member` mutation. */
export type CreateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` to be created by this mutation. */
  member: MemberInput;
};

/** The output of our create `Member` mutation. */
export type CreateMemberPayload = {
  __typename?: 'CreateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was created by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Member` mutation. */
export type CreateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the create `PageTr` mutation. */
export type CreatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PageTr` to be created by this mutation. */
  pageTr: PageTrInput;
};

/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayload = {
  __typename?: 'CreatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was created by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** All input for the `createUploadUrl` mutation. */
export type CreateUploadUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * You must provide the content type (or MIME type) of the content you intend
   * to upload. For further information about content types, see
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
   */
  contentType: Scalars['String'];
};

/** The output of our `createUploadUrl` mutation. */
export type CreateUploadUrlPayload = {
  __typename?: 'CreateUploadUrlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  formData: Scalars['String'];
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Upload content to this signed URL. */
  uploadUrl: Scalars['String'];
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventNodeId: Maybe<Scalars['ID']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteEventTag` mutation. */
export type DeleteEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventTag` mutation. */
export type DeleteEventTagPayload = {
  __typename?: 'DeleteEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTagNodeId: Maybe<Scalars['ID']>;
  /** The `EventTag` that was deleted by this mutation. */
  eventTag: Maybe<EventTag>;
  /** An edge for our `EventTag`. May be used by Relay 1. */
  eventTagEdge: Maybe<EventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTag` mutation. */
export type DeleteEventTagPayloadEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};

/** All input for the `deleteEventTagTr` mutation. */
export type DeleteEventTagTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  tagId: Scalars['BigInt'];
};

/** The output of our delete `EventTagTr` mutation. */
export type DeleteEventTagTrPayload = {
  __typename?: 'DeleteEventTagTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTagTrNodeId: Maybe<Scalars['ID']>;
  /** The `EventTagTr` that was deleted by this mutation. */
  eventTagTr: Maybe<EventTagTr>;
  /** An edge for our `EventTagTr`. May be used by Relay 1. */
  eventTagTrEdge: Maybe<EventTagTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventTagTr`. */
  tag: Maybe<EventTag>;
};


/** The output of our delete `EventTagTr` mutation. */
export type DeleteEventTagTrPayloadEventTagTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};

/** All input for the `deleteEventTemplate` mutation. */
export type DeleteEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayload = {
  __typename?: 'DeleteEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTemplateNodeId: Maybe<Scalars['ID']>;
  /** The `EventTemplate` that was deleted by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `deleteEventTemplateTr` mutation. */
export type DeleteEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `EventTemplateTr` mutation. */
export type DeleteEventTemplateTrPayload = {
  __typename?: 'DeleteEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTemplateTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was deleted by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTemplateTr` mutation. */
export type DeleteEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the `deleteEventTr` mutation. */
export type DeleteEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `EventTr` mutation. */
export type DeleteEventTrPayload = {
  __typename?: 'DeleteEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was deleted by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTr` mutation. */
export type DeleteEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the `deleteEventViaEventTag` mutation. */
export type DeleteEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  tagId: Scalars['Int'];
};

/** The output of our delete `EventViaEventTag` mutation. */
export type DeleteEventViaEventTagPayload = {
  __typename?: 'DeleteEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventViaEventTagNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was deleted by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our delete `EventViaEventTag` mutation. */
export type DeleteEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the `deleteEventViaGroup` mutation. */
export type DeleteEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  groupId: Scalars['Int'];
};

/** The output of our delete `EventViaGroup` mutation. */
export type DeleteEventViaGroupPayload = {
  __typename?: 'DeleteEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventViaGroupNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was deleted by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventViaGroup` mutation. */
export type DeleteEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteGroupTr` mutation. */
export type DeleteGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `GroupTr` mutation. */
export type DeleteGroupTrPayload = {
  __typename?: 'DeleteGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGroupTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was deleted by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GroupTr` mutation. */
export type DeleteGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the `deleteMemberByUsername` mutation. */
export type DeleteMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};

/** All input for the `deleteMember` mutation. */
export type DeleteMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Member` mutation. */
export type DeleteMemberPayload = {
  __typename?: 'DeleteMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedMemberNodeId: Maybe<Scalars['ID']>;
  /** The `Member` that was deleted by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Member` mutation. */
export type DeleteMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `deletePage` mutation. */
export type DeletePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** The output of our delete `Page` mutation. */
export type DeletePagePayload = {
  __typename?: 'DeletePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageNodeId: Maybe<Scalars['ID']>;
  /** The `Page` that was deleted by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Page` mutation. */
export type DeletePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `deletePageTr` mutation. */
export type DeletePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayload = {
  __typename?: 'DeletePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was deleted by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

export type Event = {
  __typename?: 'Event';
  endsAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `EventViaEventTag`. */
  eventViaEventTags: EventViaEventTagsConnection;
  /** Reads and enables pagination through a set of `EventViaGroup`. */
  eventViaGroups: EventViaGroupsConnection;
  id: Scalars['BigInt'];
  image: Maybe<ResponsiveImage>;
  imageFile: Maybe<Scalars['String']>;
  overrideImageFile: Maybe<Scalars['String']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `EventTr`. */
  translations: EventTrsConnection;
};


export type EventEventViaEventTagsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaEventTagCondition>;
  filter?: Maybe<EventViaEventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};


export type EventEventViaGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaGroupCondition>;
  filter?: Maybe<EventViaGroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};


export type EventTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `endsAt` field. */
  endsAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `overrideImageFile` field. */
  overrideImageFile?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `special` field. */
  special?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startsAt` field. */
  startsAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Filter by the object’s `endsAt` field. */
  endsAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `overrideImageFile` field. */
  overrideImageFile?: Maybe<StringFilter>;
  /** Filter by the object’s `special` field. */
  special?: Maybe<BooleanFilter>;
  /** Filter by the object’s `startsAt` field. */
  startsAt?: Maybe<DatetimeFilter>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  endsAt: Scalars['Datetime'];
  id?: Maybe<Scalars['BigInt']>;
  overrideImageFile?: Maybe<Scalars['String']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  endsAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['BigInt']>;
  overrideImageFile?: Maybe<Scalars['String']>;
  special?: Maybe<Scalars['Boolean']>;
  startsAt?: Maybe<Scalars['Datetime']>;
};

export type EventTag = {
  __typename?: 'EventTag';
  /** Reads and enables pagination through a set of `EventViaEventTag`. */
  eventViaEventTagsByTagId: EventViaEventTagsConnection;
  id: Scalars['BigInt'];
  image: Maybe<ResponsiveImage>;
  imageFile: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `EventTagTr`. */
  translations: EventTagTrsConnection;
};


export type EventTagEventViaEventTagsByTagIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaEventTagCondition>;
  filter?: Maybe<EventViaEventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};


export type EventTagTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagTrCondition>;
  filter?: Maybe<EventTagTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};

/**
 * A condition to be used against `EventTag` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EventTagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageFile` field. */
  imageFile?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTag` object types. All fields are combined with a logical ‘and.’ */
export type EventTagFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageFile` field. */
  imageFile?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTag` */
export type EventTagInput = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
};

/** Represents an update to a `EventTag`. Fields that are set will be updated. */
export type EventTagPatch = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
};

export type EventTagTr = {
  __typename?: 'EventTagTr';
  languageCode: TrLanguage;
  /** Reads a single `EventTag` that is related to this `EventTagTr`. */
  tag: Maybe<EventTag>;
  tagId: Scalars['BigInt'];
  title: Scalars['String'];
};

/**
 * A condition to be used against `EventTagTr` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EventTagTrCondition = {
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTagTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTagTrFilter = {
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTagTr` */
export type EventTagTrInput = {
  languageCode: TrLanguage;
  tagId: Scalars['BigInt'];
  title: Scalars['String'];
};

/** Represents an update to a `EventTagTr`. Fields that are set will be updated. */
export type EventTagTrPatch = {
  languageCode?: Maybe<TrLanguage>;
  tagId?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventTagTr` values. */
export type EventTagTrsConnection = {
  __typename?: 'EventTagTrsConnection';
  /** A list of edges which contains the `EventTagTr` and cursor to aid in pagination. */
  edges: Array<EventTagTrsEdge>;
  /** A list of `EventTagTr` objects. */
  nodes: Array<EventTagTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTagTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTagTr` edge in the connection. */
export type EventTagTrsEdge = {
  __typename?: 'EventTagTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTagTr` at the end of the edge. */
  node: EventTagTr;
};

/** Methods to use when ordering `EventTagTr`. */
export enum EventTagTrsOrderBy {
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `EventTag` values. */
export type EventTagsConnection = {
  __typename?: 'EventTagsConnection';
  /** A list of edges which contains the `EventTag` and cursor to aid in pagination. */
  edges: Array<EventTagsEdge>;
  /** A list of `EventTag` objects. */
  nodes: Array<EventTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTag` edge in the connection. */
export type EventTagsEdge = {
  __typename?: 'EventTagsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTag` at the end of the edge. */
  node: EventTag;
};

/** Methods to use when ordering `EventTag`. */
export enum EventTagsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageFileAsc = 'IMAGE_FILE_ASC',
  ImageFileDesc = 'IMAGE_FILE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type EventTemplate = {
  __typename?: 'EventTemplate';
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `EventTemplateTr`. */
  translations: EventTemplateTrsConnection;
};


export type EventTemplateTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateTrCondition>;
  filter?: Maybe<EventTemplateTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/**
 * A condition to be used against `EventTemplate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTemplateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventTemplate` object types. All fields are combined with a logical ‘and.’ */
export type EventTemplateFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
};

/** An input for mutations affecting `EventTemplate` */
export type EventTemplateInput = {
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `EventTemplate`. Fields that are set will be updated. */
export type EventTemplatePatch = {
  id?: Maybe<Scalars['BigInt']>;
};

export type EventTemplateTr = {
  __typename?: 'EventTemplateTr';
  description: Scalars['String'];
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
  venue: Scalars['String'];
};

/**
 * A condition to be used against `EventTemplateTr` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTemplateTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventTemplateId` field. */
  eventTemplateId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTemplateTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTemplateTrFilter = {
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `eventTemplateId` field. */
  eventTemplateId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTemplateTr` */
export type EventTemplateTrInput = {
  description: Scalars['String'];
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** Represents an update to a `EventTemplateTr`. Fields that are set will be updated. */
export type EventTemplateTrPatch = {
  description?: Maybe<Scalars['String']>;
  eventTemplateId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  title?: Maybe<Scalars['String']>;
  venue?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventTemplateTr` values. */
export type EventTemplateTrsConnection = {
  __typename?: 'EventTemplateTrsConnection';
  /** A list of edges which contains the `EventTemplateTr` and cursor to aid in pagination. */
  edges: Array<EventTemplateTrsEdge>;
  /** A list of `EventTemplateTr` objects. */
  nodes: Array<EventTemplateTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTemplateTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTemplateTr` edge in the connection. */
export type EventTemplateTrsEdge = {
  __typename?: 'EventTemplateTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTemplateTr` at the end of the edge. */
  node: EventTemplateTr;
};

/** Methods to use when ordering `EventTemplateTr`. */
export enum EventTemplateTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventTemplateIdAsc = 'EVENT_TEMPLATE_ID_ASC',
  EventTemplateIdDesc = 'EVENT_TEMPLATE_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

/** A connection to a list of `EventTemplate` values. */
export type EventTemplatesConnection = {
  __typename?: 'EventTemplatesConnection';
  /** A list of edges which contains the `EventTemplate` and cursor to aid in pagination. */
  edges: Array<EventTemplatesEdge>;
  /** A list of `EventTemplate` objects. */
  nodes: Array<EventTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTemplate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTemplate` edge in the connection. */
export type EventTemplatesEdge = {
  __typename?: 'EventTemplatesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTemplate` at the end of the edge. */
  node: EventTemplate;
};

/** Methods to use when ordering `EventTemplate`. */
export enum EventTemplatesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type EventTr = {
  __typename?: 'EventTr';
  description: Scalars['String'];
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  slug: Scalars['String'];
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** A condition to be used against `EventTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTrFilter = {
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTr` */
export type EventTrInput = {
  description: Scalars['String'];
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  slug: Scalars['String'];
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** Represents an update to a `EventTr`. Fields that are set will be updated. */
export type EventTrPatch = {
  description?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  venue?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventTr` values. */
export type EventTrsConnection = {
  __typename?: 'EventTrsConnection';
  /** A list of edges which contains the `EventTr` and cursor to aid in pagination. */
  edges: Array<EventTrsEdge>;
  /** A list of `EventTr` objects. */
  nodes: Array<EventTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTr` edge in the connection. */
export type EventTrsEdge = {
  __typename?: 'EventTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTr` at the end of the edge. */
  node: EventTr;
};

/** Methods to use when ordering `EventTr`. */
export enum EventTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

export type EventViaEventTag = {
  __typename?: 'EventViaEventTag';
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
  tagId: Scalars['Int'];
};

/**
 * A condition to be used against `EventViaEventTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventViaEventTagCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `EventViaEventTag` object types. All fields are combined with a logical ‘and.’ */
export type EventViaEventTagFilter = {
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `EventViaEventTag` */
export type EventViaEventTagInput = {
  eventId: Scalars['BigInt'];
  tagId: Scalars['Int'];
};

/** Represents an update to a `EventViaEventTag`. Fields that are set will be updated. */
export type EventViaEventTagPatch = {
  eventId?: Maybe<Scalars['BigInt']>;
  tagId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `EventViaEventTag` values. */
export type EventViaEventTagsConnection = {
  __typename?: 'EventViaEventTagsConnection';
  /** A list of edges which contains the `EventViaEventTag` and cursor to aid in pagination. */
  edges: Array<EventViaEventTagsEdge>;
  /** A list of `EventViaEventTag` objects. */
  nodes: Array<EventViaEventTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventViaEventTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventViaEventTag` edge in the connection. */
export type EventViaEventTagsEdge = {
  __typename?: 'EventViaEventTagsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventViaEventTag` at the end of the edge. */
  node: EventViaEventTag;
};

/** Methods to use when ordering `EventViaEventTag`. */
export enum EventViaEventTagsOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC'
}

export type EventViaGroup = {
  __typename?: 'EventViaGroup';
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  groupId: Scalars['Int'];
};

/**
 * A condition to be used against `EventViaGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventViaGroupCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `EventViaGroup` object types. All fields are combined with a logical ‘and.’ */
export type EventViaGroupFilter = {
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `EventViaGroup` */
export type EventViaGroupInput = {
  eventId: Scalars['BigInt'];
  groupId: Scalars['Int'];
};

/** Represents an update to a `EventViaGroup`. Fields that are set will be updated. */
export type EventViaGroupPatch = {
  eventId?: Maybe<Scalars['BigInt']>;
  groupId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `EventViaGroup` values. */
export type EventViaGroupsConnection = {
  __typename?: 'EventViaGroupsConnection';
  /** A list of edges which contains the `EventViaGroup` and cursor to aid in pagination. */
  edges: Array<EventViaGroupsEdge>;
  /** A list of `EventViaGroup` objects. */
  nodes: Array<EventViaGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventViaGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventViaGroup` edge in the connection. */
export type EventViaGroupsEdge = {
  __typename?: 'EventViaGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventViaGroup` at the end of the edge. */
  node: EventViaGroup;
};

/** Methods to use when ordering `EventViaGroup`. */
export enum EventViaGroupsOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  EndsAtAsc = 'ENDS_AT_ASC',
  EndsAtDesc = 'ENDS_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OverrideImageFileAsc = 'OVERRIDE_IMAGE_FILE_ASC',
  OverrideImageFileDesc = 'OVERRIDE_IMAGE_FILE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SpecialAsc = 'SPECIAL_ASC',
  SpecialDesc = 'SPECIAL_DESC',
  StartsAtAsc = 'STARTS_AT_ASC',
  StartsAtDesc = 'STARTS_AT_DESC'
}

export type Group = {
  __typename?: 'Group';
  /** Reads and enables pagination through a set of `EventViaGroup`. */
  eventViaGroups: EventViaGroupsConnection;
  id: Scalars['BigInt'];
  image: ResponsiveImage;
  imageFile: Scalars['String'];
  /** Reads and enables pagination through a set of `GroupTr`. */
  translations: GroupTrsConnection;
};


export type GroupEventViaGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaGroupCondition>;
  filter?: Maybe<EventViaGroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};


export type GroupTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageFile` field. */
  imageFile?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageFile` field. */
  imageFile?: Maybe<StringFilter>;
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile: Scalars['String'];
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
};

export type GroupTr = {
  __typename?: 'GroupTr';
  description: Scalars['String'];
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  shortDescription: Scalars['String'];
  slug: Scalars['String'];
  title: Scalars['String'];
};

/** A condition to be used against `GroupTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `GroupTr` object types. All fields are combined with a logical ‘and.’ */
export type GroupTrFilter = {
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** An input for mutations affecting `GroupTr` */
export type GroupTrInput = {
  description: Scalars['String'];
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  shortDescription: Scalars['String'];
  slug: Scalars['String'];
  title: Scalars['String'];
};

/** Represents an update to a `GroupTr`. Fields that are set will be updated. */
export type GroupTrPatch = {
  description?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  shortDescription?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `GroupTr` values. */
export type GroupTrsConnection = {
  __typename?: 'GroupTrsConnection';
  /** A list of edges which contains the `GroupTr` and cursor to aid in pagination. */
  edges: Array<GroupTrsEdge>;
  /** A list of `GroupTr` objects. */
  nodes: Array<GroupTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GroupTr` edge in the connection. */
export type GroupTrsEdge = {
  __typename?: 'GroupTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GroupTr` at the end of the edge. */
  node: GroupTr;
};

/** Methods to use when ordering `GroupTr`. */
export enum GroupTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageFileAsc = 'IMAGE_FILE_ASC',
  ImageFileDesc = 'IMAGE_FILE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
};

export type Member = {
  __typename?: 'Member';
  id: Scalars['UUID'];
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Member` object types. All fields are combined with a logical ‘and.’ */
export type MemberFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
};

/** An input for mutations affecting `Member` */
export type MemberInput = {
  id?: Maybe<Scalars['UUID']>;
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** Represents an update to a `Member`. Fields that are set will be updated. */
export type MemberPatch = {
  id?: Maybe<Scalars['UUID']>;
  isActive?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  authenticate: Scalars['String'];
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `EventTag`. */
  createEventTag: Maybe<CreateEventTagPayload>;
  /** Creates a single `EventTagTr`. */
  createEventTagTr: Maybe<CreateEventTagTrPayload>;
  /** Creates a single `EventTemplate`. */
  createEventTemplate: Maybe<CreateEventTemplatePayload>;
  /** Creates a single `EventTemplateTr`. */
  createEventTemplateTr: Maybe<CreateEventTemplateTrPayload>;
  /** Creates a single `EventTr`. */
  createEventTr: Maybe<CreateEventTrPayload>;
  /** Creates a single `EventViaEventTag`. */
  createEventViaEventTag: Maybe<CreateEventViaEventTagPayload>;
  /** Creates a single `EventViaGroup`. */
  createEventViaGroup: Maybe<CreateEventViaGroupPayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `GroupTr`. */
  createGroupTr: Maybe<CreateGroupTrPayload>;
  /** Creates a single `Member`. */
  createMember: Maybe<CreateMemberPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `PageTr`. */
  createPageTr: Maybe<CreatePageTrPayload>;
  /** Get a signed URL for uploading files. It will expire in 5 minutes. */
  createUploadUrl: Maybe<CreateUploadUrlPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `EventTag` using a unique key. */
  deleteEventTag: Maybe<DeleteEventTagPayload>;
  /** Deletes a single `EventTagTr` using a unique key. */
  deleteEventTagTr: Maybe<DeleteEventTagTrPayload>;
  /** Deletes a single `EventTemplate` using a unique key. */
  deleteEventTemplate: Maybe<DeleteEventTemplatePayload>;
  /** Deletes a single `EventTemplateTr` using a unique key. */
  deleteEventTemplateTr: Maybe<DeleteEventTemplateTrPayload>;
  /** Deletes a single `EventTr` using a unique key. */
  deleteEventTr: Maybe<DeleteEventTrPayload>;
  /** Deletes a single `EventViaEventTag` using a unique key. */
  deleteEventViaEventTag: Maybe<DeleteEventViaEventTagPayload>;
  /** Deletes a single `EventViaGroup` using a unique key. */
  deleteEventViaGroup: Maybe<DeleteEventViaGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `GroupTr` using a unique key. */
  deleteGroupTr: Maybe<DeleteGroupTrPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMember: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMemberByUsername: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Page` using a unique key. */
  deletePage: Maybe<DeletePagePayload>;
  /** Deletes a single `PageTr` using a unique key. */
  deletePageTr: Maybe<DeletePageTrPayload>;
  logout: Maybe<Scalars['Boolean']>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `EventTag` using a unique key and a patch. */
  updateEventTag: Maybe<UpdateEventTagPayload>;
  /** Updates a single `EventTagTr` using a unique key and a patch. */
  updateEventTagTr: Maybe<UpdateEventTagTrPayload>;
  /** Updates a single `EventTemplate` using a unique key and a patch. */
  updateEventTemplate: Maybe<UpdateEventTemplatePayload>;
  /** Updates a single `EventTemplateTr` using a unique key and a patch. */
  updateEventTemplateTr: Maybe<UpdateEventTemplateTrPayload>;
  /** Updates a single `EventTr` using a unique key and a patch. */
  updateEventTr: Maybe<UpdateEventTrPayload>;
  /** Updates a single `EventViaEventTag` using a unique key and a patch. */
  updateEventViaEventTag: Maybe<UpdateEventViaEventTagPayload>;
  /** Updates a single `EventViaGroup` using a unique key and a patch. */
  updateEventViaGroup: Maybe<UpdateEventViaGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `GroupTr` using a unique key and a patch. */
  updateGroupTr: Maybe<UpdateGroupTrPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMember: Maybe<UpdateMemberPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMemberByUsername: Maybe<UpdateMemberPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `PageTr` using a unique key and a patch. */
  updatePageTr: Maybe<UpdatePageTrPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAuthenticateArgs = {
  input: AuthenticateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTagArgs = {
  input: CreateEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTagTrArgs = {
  input: CreateEventTagTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTemplateArgs = {
  input: CreateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTemplateTrArgs = {
  input: CreateEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTrArgs = {
  input: CreateEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventViaEventTagArgs = {
  input: CreateEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventViaGroupArgs = {
  input: CreateEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupTrArgs = {
  input: CreateGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMemberArgs = {
  input: CreateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageTrArgs = {
  input: CreatePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUploadUrlArgs = {
  input: CreateUploadUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTagArgs = {
  input: DeleteEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTagTrArgs = {
  input: DeleteEventTagTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTemplateArgs = {
  input: DeleteEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTemplateTrArgs = {
  input: DeleteEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTrArgs = {
  input: DeleteEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventViaEventTagArgs = {
  input: DeleteEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventViaGroupArgs = {
  input: DeleteEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupTrArgs = {
  input: DeleteGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberArgs = {
  input: DeleteMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberByUsernameArgs = {
  input: DeleteMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageArgs = {
  input: DeletePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageTrArgs = {
  input: DeletePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTagArgs = {
  input: UpdateEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTagTrArgs = {
  input: UpdateEventTagTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTemplateArgs = {
  input: UpdateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTemplateTrArgs = {
  input: UpdateEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTrArgs = {
  input: UpdateEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventViaEventTagArgs = {
  input: UpdateEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventViaGroupArgs = {
  input: UpdateEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupTrArgs = {
  input: UpdateGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberByUsernameArgs = {
  input: UpdateMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageTrArgs = {
  input: UpdatePageTrInput;
};

export type Page = {
  __typename?: 'Page';
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `PageTr`. */
  translations: PageTrsConnection;
};


export type PageTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Page` object types. All fields are combined with a logical ‘and.’ */
export type PageFilter = {
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  name: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  name?: Maybe<Scalars['String']>;
};

export type PageTr = {
  __typename?: 'PageTr';
  content: Scalars['String'];
  languageCode: TrLanguage;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  pageName: Scalars['String'];
};

/** A condition to be used against `PageTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageTrCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `pageName` field. */
  pageName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PageTr` object types. All fields are combined with a logical ‘and.’ */
export type PageTrFilter = {
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `pageName` field. */
  pageName?: Maybe<StringFilter>;
};

/** An input for mutations affecting `PageTr` */
export type PageTrInput = {
  content: Scalars['String'];
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** Represents an update to a `PageTr`. Fields that are set will be updated. */
export type PageTrPatch = {
  content?: Maybe<Scalars['String']>;
  languageCode?: Maybe<TrLanguage>;
  pageName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PageTr` values. */
export type PageTrsConnection = {
  __typename?: 'PageTrsConnection';
  /** A list of edges which contains the `PageTr` and cursor to aid in pagination. */
  edges: Array<PageTrsEdge>;
  /** A list of `PageTr` objects. */
  nodes: Array<PageTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageTr` edge in the connection. */
export type PageTrsEdge = {
  __typename?: 'PageTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageTr` at the end of the edge. */
  node: PageTr;
};

/** Methods to use when ordering `PageTr`. */
export enum PageTrsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PageNameAsc = 'PAGE_NAME_ASC',
  PageNameDesc = 'PAGE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export enum PagesOrderBy {
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  currentMember: Maybe<Member>;
  event: Maybe<Event>;
  eventTag: Maybe<EventTag>;
  eventTagTr: Maybe<EventTagTr>;
  /** Reads and enables pagination through a set of `EventTagTr`. */
  eventTagTrs: Maybe<EventTagTrsConnection>;
  /** Reads and enables pagination through a set of `EventTag`. */
  eventTags: Maybe<EventTagsConnection>;
  eventTemplate: Maybe<EventTemplate>;
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** Reads and enables pagination through a set of `EventTemplateTr`. */
  eventTemplateTrs: Maybe<EventTemplateTrsConnection>;
  /** Reads and enables pagination through a set of `EventTemplate`. */
  eventTemplates: Maybe<EventTemplatesConnection>;
  eventTr: Maybe<EventTr>;
  /** Reads and enables pagination through a set of `EventTr`. */
  eventTrs: Maybe<EventTrsConnection>;
  eventViaEventTag: Maybe<EventViaEventTag>;
  eventViaGroup: Maybe<EventViaGroup>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  group: Maybe<Group>;
  groupTr: Maybe<GroupTr>;
  /** Reads and enables pagination through a set of `GroupTr`. */
  groupTrs: Maybe<GroupTrsConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: Maybe<GroupsConnection>;
  member: Maybe<Member>;
  memberByUsername: Maybe<Member>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  page: Maybe<Page>;
  pageTr: Maybe<PageTr>;
  /** Reads and enables pagination through a set of `PageTr`. */
  pageTrs: Maybe<PageTrsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagTrArgs = {
  languageCode: TrLanguage;
  tagId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagTrCondition>;
  filter?: Maybe<EventTagTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagCondition>;
  filter?: Maybe<EventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateTrArgs = {
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateTrCondition>;
  filter?: Maybe<EventTemplateTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplatesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateCondition>;
  filter?: Maybe<EventTemplateFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrArgs = {
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventViaEventTagArgs = {
  eventId: Scalars['BigInt'];
  tagId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventViaGroupArgs = {
  eventId: Scalars['BigInt'];
  groupId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrArgs = {
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberByUsernameArgs = {
  username: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MemberCondition>;
  filter?: Maybe<MemberFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrArgs = {
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageCondition>;
  filter?: Maybe<PageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

export type ResponsiveImage = {
  __typename?: 'ResponsiveImage';
  src: Scalars['String'];
  srcSetJpeg: Scalars['String'];
  srcSetWebp: Scalars['String'];
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
};

export enum TrLanguage {
  Da = 'DA',
  En = 'EN'
}

/** A filter to be used against TrLanguage fields. All fields are combined with a logical ‘and.’ */
export type TrLanguageFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<TrLanguage>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TrLanguage>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TrLanguage>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<TrLanguage>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TrLanguage>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TrLanguage>;
};


/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `updateEventTag` mutation. */
export type UpdateEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventTag` being updated. */
  patch: EventTagPatch;
};

/** The output of our update `EventTag` mutation. */
export type UpdateEventTagPayload = {
  __typename?: 'UpdateEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTag` that was updated by this mutation. */
  eventTag: Maybe<EventTag>;
  /** An edge for our `EventTag`. May be used by Relay 1. */
  eventTagEdge: Maybe<EventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTag` mutation. */
export type UpdateEventTagPayloadEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};

/** All input for the `updateEventTagTr` mutation. */
export type UpdateEventTagTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventTagTr` being updated. */
  patch: EventTagTrPatch;
  tagId: Scalars['BigInt'];
};

/** The output of our update `EventTagTr` mutation. */
export type UpdateEventTagTrPayload = {
  __typename?: 'UpdateEventTagTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTagTr` that was updated by this mutation. */
  eventTagTr: Maybe<EventTagTr>;
  /** An edge for our `EventTagTr`. May be used by Relay 1. */
  eventTagTrEdge: Maybe<EventTagTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventTagTr`. */
  tag: Maybe<EventTag>;
};


/** The output of our update `EventTagTr` mutation. */
export type UpdateEventTagTrPayloadEventTagTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};

/** All input for the `updateEventTemplate` mutation. */
export type UpdateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventTemplate` being updated. */
  patch: EventTemplatePatch;
};

/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayload = {
  __typename?: 'UpdateEventTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was updated by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `updateEventTemplateTr` mutation. */
export type UpdateEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventTemplateTr` being updated. */
  patch: EventTemplateTrPatch;
};

/** The output of our update `EventTemplateTr` mutation. */
export type UpdateEventTemplateTrPayload = {
  __typename?: 'UpdateEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was updated by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTemplateTr` mutation. */
export type UpdateEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the `updateEventTr` mutation. */
export type UpdateEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventTr` being updated. */
  patch: EventTrPatch;
};

/** The output of our update `EventTr` mutation. */
export type UpdateEventTrPayload = {
  __typename?: 'UpdateEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was updated by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTr` mutation. */
export type UpdateEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the `updateEventViaEventTag` mutation. */
export type UpdateEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventViaEventTag` being updated. */
  patch: EventViaEventTagPatch;
  tagId: Scalars['Int'];
};

/** The output of our update `EventViaEventTag` mutation. */
export type UpdateEventViaEventTagPayload = {
  __typename?: 'UpdateEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was updated by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our update `EventViaEventTag` mutation. */
export type UpdateEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the `updateEventViaGroup` mutation. */
export type UpdateEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  groupId: Scalars['Int'];
  /** An object where the defined keys will be set on the `EventViaGroup` being updated. */
  patch: EventViaGroupPatch;
};

/** The output of our update `EventViaGroup` mutation. */
export type UpdateEventViaGroupPayload = {
  __typename?: 'UpdateEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was updated by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventViaGroup` mutation. */
export type UpdateEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateGroupTr` mutation. */
export type UpdateGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `GroupTr` being updated. */
  patch: GroupTrPatch;
};

/** The output of our update `GroupTr` mutation. */
export type UpdateGroupTrPayload = {
  __typename?: 'UpdateGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was updated by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GroupTr` mutation. */
export type UpdateGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the `updateMemberByUsername` mutation. */
export type UpdateMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
  username: Scalars['String'];
};

/** All input for the `updateMember` mutation. */
export type UpdateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
};

/** The output of our update `Member` mutation. */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was updated by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Member` mutation. */
export type UpdateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `updatePageTr` mutation. */
export type UpdatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
  /** An object where the defined keys will be set on the `PageTr` being updated. */
  patch: PageTrPatch;
};

/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayload = {
  __typename?: 'UpdatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was updated by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

export type AuthenticateMutationVariables = Exact<{
  username: Scalars['String'];
  password: Scalars['String'];
}>;


export type AuthenticateMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'authenticate'>
);

export type CalendarEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
  startsBefore?: Maybe<Scalars['Datetime']>;
}>;


export type CalendarEventsQueryQuery = (
  { __typename?: 'Query' }
  & { events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & CalendarEventFragment
    )> }
  )> }
);

export type CalendarEventFragment = (
  { __typename?: 'Event' }
  & Pick<Event, 'endsAt' | 'id' | 'startsAt' | 'special'>
  & { translations: (
    { __typename?: 'EventTrsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTr' }
      & Pick<EventTr, 'slug' | 'title' | 'languageCode' | 'description'>
    )> }
  ) }
);

export type GetMeQueryVariables = Exact<{ [key: string]: never; }>;


export type GetMeQuery = (
  { __typename?: 'Query' }
  & { currentMember: Maybe<(
    { __typename?: 'Member' }
    & Pick<Member, 'name' | 'id' | 'userRole'>
  )> }
);

export type GetUploadUrlMutationVariables = Exact<{
  contentType: Scalars['String'];
}>;


export type GetUploadUrlMutation = (
  { __typename?: 'Mutation' }
  & { createUploadUrl: Maybe<(
    { __typename?: 'CreateUploadUrlPayload' }
    & Pick<CreateUploadUrlPayload, 'uploadUrl' | 'formData'>
  )> }
);

export type HomeEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
}>;


export type HomeEventsQueryQuery = (
  { __typename?: 'Query' }
  & { specialEvents: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & Pick<Event, 'imageFile'>
      & { image: Maybe<(
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'src' | 'srcSetWebp' | 'srcSetJpeg'>
      )> }
      & EventFragment
    )> }
  )>, events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & EventFragment
    )> }
  )> }
);

export type EventFragment = (
  { __typename?: 'Event' }
  & Pick<Event, 'endsAt' | 'id' | 'startsAt' | 'special'>
  & { translations: (
    { __typename?: 'EventTrsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTr' }
      & Pick<EventTr, 'slug' | 'title' | 'languageCode' | 'description' | 'eventId'>
    )> }
  ) }
);

export type HomeGroupsQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeGroupsQueryQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<(
    { __typename?: 'GroupsConnection' }
    & { nodes: Array<(
      { __typename?: 'Group' }
      & Pick<Group, 'id'>
      & { image: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'src' | 'srcSetWebp' | 'srcSetJpeg'>
      ), translations: (
        { __typename?: 'GroupTrsConnection' }
        & { nodes: Array<(
          { __typename?: 'GroupTr' }
          & Pick<GroupTr, 'languageCode' | 'title' | 'shortDescription' | 'slug' | 'groupId'>
        )> }
      ) }
    )> }
  )> }
);

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'logout'>
);

export type PageQueryQueryVariables = Exact<{
  name?: Maybe<Scalars['String']>;
}>;


export type PageQueryQuery = (
  { __typename?: 'Query' }
  & { page: Maybe<(
    { __typename?: 'Page' }
    & Pick<Page, 'name'>
    & { translations: (
      { __typename?: 'PageTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'PageTr' }
        & PageTranslationFragment
      )> }
    ) }
  )> }
);

export type PageTranslationFragment = (
  { __typename: 'PageTr' }
  & Pick<PageTr, 'content' | 'languageCode' | 'pageName'>
);

export type UpdatePageTranslationMutationVariables = Exact<{
  content: Scalars['String'];
  pageName: Scalars['String'];
  languageCode: TrLanguage;
}>;


export type UpdatePageTranslationMutation = (
  { __typename?: 'Mutation' }
  & { updatePageTr: Maybe<(
    { __typename?: 'UpdatePageTrPayload' }
    & { pageTr: Maybe<(
      { __typename?: 'PageTr' }
      & PageTranslationFragment
    )> }
  )> }
);

export const CalendarEventFragmentDoc = gql`
    fragment calendarEvent on Event {
  translations {
    nodes {
      slug
      title
      languageCode
      description
    }
  }
  endsAt
  id
  startsAt
  special
}
    ` as unknown as DocumentNode<CalendarEventFragment, unknown>;
export const EventFragmentDoc = gql`
    fragment event on Event {
  translations {
    nodes {
      slug
      title
      languageCode
      description
      eventId
    }
  }
  endsAt
  id
  startsAt
  special
}
    ` as unknown as DocumentNode<EventFragment, unknown>;
export const PageTranslationFragmentDoc = gql`
    fragment PageTranslation on PageTr {
  __typename
  content
  languageCode
  pageName
}
    ` as unknown as DocumentNode<PageTranslationFragment, unknown>;
export const AuthenticateDocument = gql`
    mutation Authenticate($username: String!, $password: String!) {
  authenticate(input: {username: $username, password: $password})
}
    ` as unknown as DocumentNode<AuthenticateMutation, AuthenticateMutationVariables>;
export const CalendarEventsQueryDocument = gql`
    query CalendarEventsQuery($startsAfter: Datetime, $startsBefore: Datetime) {
  events(
    filter: {startsAt: {greaterThan: $startsAfter, lessThan: $startsBefore}}
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...calendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}` as unknown as DocumentNode<CalendarEventsQueryQuery, CalendarEventsQueryQueryVariables>;
export const GetMeDocument = gql`
    query GetMe {
  currentMember {
    name
    id
    userRole
  }
}
    ` as unknown as DocumentNode<GetMeQuery, GetMeQueryVariables>;
export const GetUploadUrlDocument = gql`
    mutation GetUploadUrl($contentType: String!) {
  createUploadUrl(input: {contentType: $contentType}) {
    uploadUrl
    formData
  }
}
    ` as unknown as DocumentNode<GetUploadUrlMutation, GetUploadUrlMutationVariables>;
export const HomeEventsQueryDocument = gql`
    query HomeEventsQuery($startsAfter: Datetime) {
  specialEvents: events(
    filter: {special: {equalTo: true}, startsAt: {greaterThan: $startsAfter}}
    first: 1
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...event
      image {
        src
        srcSetWebp
        srcSetJpeg
      }
      imageFile
    }
  }
  events(
    filter: {startsAt: {greaterThan: $startsAfter}}
    first: 10
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...event
    }
  }
}
    ${EventFragmentDoc}` as unknown as DocumentNode<HomeEventsQueryQuery, HomeEventsQueryQueryVariables>;
export const HomeGroupsQueryDocument = gql`
    query HomeGroupsQuery {
  groups {
    nodes {
      id
      image {
        src
        srcSetWebp
        srcSetJpeg
      }
      translations {
        nodes {
          languageCode
          title
          shortDescription
          slug
          groupId
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<HomeGroupsQueryQuery, HomeGroupsQueryQueryVariables>;
export const LogoutDocument = gql`
    mutation Logout {
  logout
}
    ` as unknown as DocumentNode<LogoutMutation, LogoutMutationVariables>;
export const PageQueryDocument = gql`
    query PageQuery($name: String = "") {
  page(name: $name) {
    name
    translations {
      nodes {
        ...PageTranslation
      }
    }
  }
}
    ${PageTranslationFragmentDoc}` as unknown as DocumentNode<PageQueryQuery, PageQueryQueryVariables>;
export const UpdatePageTranslationDocument = gql`
    mutation UpdatePageTranslation($content: String!, $pageName: String!, $languageCode: TrLanguage!) {
  updatePageTr(
    input: {patch: {content: $content}, pageName: $pageName, languageCode: $languageCode}
  ) {
    pageTr {
      ...PageTranslation
    }
  }
}
    ${PageTranslationFragmentDoc}` as unknown as DocumentNode<UpdatePageTranslationMutation, UpdatePageTranslationMutationVariables>;