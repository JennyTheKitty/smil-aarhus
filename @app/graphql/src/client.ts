/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};

export type AuthenticateInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
};

/** All input for the create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventViaEventTag` to be created by this mutation. */
  eventViaEventTag: EventViaEventTagInput;
};

/** The output of our create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagPayload = {
  __typename?: 'CreateEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was created by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our create `EventViaEventTag` mutation. */
export type CreateEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the create `EventViaGroup` mutation. */
export type CreateEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventViaGroup` to be created by this mutation. */
  eventViaGroup: EventViaGroupInput;
};

/** The output of our create `EventViaGroup` mutation. */
export type CreateEventViaGroupPayload = {
  __typename?: 'CreateEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was created by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventViaGroup` mutation. */
export type CreateEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the create `Image` mutation. */
export type CreateImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Image` to be created by this mutation. */
  image: ImageInput;
};

/** The output of our create `Image` mutation. */
export type CreateImagePayload = {
  __typename?: 'CreateImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Image` that was created by this mutation. */
  image: Maybe<Image>;
  /** An edge for our `Image`. May be used by Relay 1. */
  imageEdge: Maybe<ImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Image` mutation. */
export type CreateImagePayloadImageEdgeArgs = {
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};

/** All input for the create `Member` mutation. */
export type CreateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` to be created by this mutation. */
  member: MemberInput;
};

/** The output of our create `Member` mutation. */
export type CreateMemberPayload = {
  __typename?: 'CreateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was created by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Member` mutation. */
export type CreateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the create `PageTr` mutation. */
export type CreatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PageTr` to be created by this mutation. */
  pageTr: PageTrInput;
};

/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayload = {
  __typename?: 'CreatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was created by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** All input for the create `Picture` mutation. */
export type CreatePictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Picture` to be created by this mutation. */
  picture: PictureInput;
};

/** The output of our create `Picture` mutation. */
export type CreatePicturePayload = {
  __typename?: 'CreatePicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Image` that is related to this `Picture`. */
  imageByImage: Maybe<Image>;
  /** The `Picture` that was created by this mutation. */
  picture: Maybe<Picture>;
  /** An edge for our `Picture`. May be used by Relay 1. */
  pictureEdge: Maybe<PicturesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Picture` mutation. */
export type CreatePicturePayloadPictureEdgeArgs = {
  orderBy?: Maybe<Array<PicturesOrderBy>>;
};

/** All input for the `createUploadUrl` mutation. */
export type CreateUploadUrlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * You must provide the content type (or MIME type) of the content you intend
   * to upload. For further information about content types, see
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
   */
  contentType: Scalars['String'];
};

/** The output of our `createUploadUrl` mutation. */
export type CreateUploadUrlPayload = {
  __typename?: 'CreateUploadUrlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  formData: Scalars['String'];
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Upload content to this signed URL. */
  uploadUrl: Scalars['String'];
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
};

/** All input for the `deleteEventViaEventTag` mutation. */
export type DeleteEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  tagId: Scalars['BigInt'];
};

/** The output of our delete `EventViaEventTag` mutation. */
export type DeleteEventViaEventTagPayload = {
  __typename?: 'DeleteEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventViaEventTagNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was deleted by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our delete `EventViaEventTag` mutation. */
export type DeleteEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the `deleteEventViaGroup` mutation. */
export type DeleteEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  groupId: Scalars['BigInt'];
};

/** The output of our delete `EventViaGroup` mutation. */
export type DeleteEventViaGroupPayload = {
  __typename?: 'DeleteEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventViaGroupNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was deleted by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventViaGroup` mutation. */
export type DeleteEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the `deleteImage` mutation. */
export type DeleteImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Image` mutation. */
export type DeleteImagePayload = {
  __typename?: 'DeleteImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedImageNodeId: Maybe<Scalars['ID']>;
  /** The `Image` that was deleted by this mutation. */
  image: Maybe<Image>;
  /** An edge for our `Image`. May be used by Relay 1. */
  imageEdge: Maybe<ImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Image` mutation. */
export type DeleteImagePayloadImageEdgeArgs = {
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};

/** All input for the `deleteMemberByUsername` mutation. */
export type DeleteMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};

/** All input for the `deleteMember` mutation. */
export type DeleteMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Member` mutation. */
export type DeleteMemberPayload = {
  __typename?: 'DeleteMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedMemberNodeId: Maybe<Scalars['ID']>;
  /** The `Member` that was deleted by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Member` mutation. */
export type DeleteMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `deletePage` mutation. */
export type DeletePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** The output of our delete `Page` mutation. */
export type DeletePagePayload = {
  __typename?: 'DeletePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageNodeId: Maybe<Scalars['ID']>;
  /** The `Page` that was deleted by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Page` mutation. */
export type DeletePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `deletePageTr` mutation. */
export type DeletePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayload = {
  __typename?: 'DeletePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was deleted by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** All input for the `deletePicture` mutation. */
export type DeletePictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Picture` mutation. */
export type DeletePicturePayload = {
  __typename?: 'DeletePicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPictureNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Image` that is related to this `Picture`. */
  imageByImage: Maybe<Image>;
  /** The `Picture` that was deleted by this mutation. */
  picture: Maybe<Picture>;
  /** An edge for our `Picture`. May be used by Relay 1. */
  pictureEdge: Maybe<PicturesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Picture` mutation. */
export type DeletePicturePayloadPictureEdgeArgs = {
  orderBy?: Maybe<Array<PicturesOrderBy>>;
};

export type Event = {
  __typename?: 'Event';
  endsAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `EventViaGroup`. */
  groups: EventViaGroupsConnection;
  id: Scalars['BigInt'];
  /** Reads a single `Image` that is related to this `Event`. */
  imageByOverrideImage: Maybe<Image>;
  img: Maybe<ResponsiveImage>;
  isTemplate: Scalars['Boolean'];
  overrideImage: Maybe<Scalars['BigInt']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `EventViaEventTag`. */
  tags: EventViaEventTagsConnection;
  /** Reads and enables pagination through a set of `EventTr`. */
  translations: EventTrsConnection;
};


export type EventGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaGroupCondition>;
  filter?: Maybe<EventViaGroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};


export type EventTagsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaEventTagCondition>;
  filter?: Maybe<EventViaEventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};


export type EventTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `endsAt` field. */
  endsAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isTemplate` field. */
  isTemplate?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `overrideImage` field. */
  overrideImage?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `special` field. */
  special?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startsAt` field. */
  startsAt?: Maybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `EventDatum` */
export type EventDatumInput = {
  endsAt: Scalars['Datetime'];
  groupIds?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  isTemplate?: Maybe<Scalars['Boolean']>;
  overrideImageFile?: Maybe<Scalars['String']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  tagIds?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Filter by the object’s `endsAt` field. */
  endsAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `isTemplate` field. */
  isTemplate?: Maybe<BooleanFilter>;
  /** Filter by the object’s `overrideImage` field. */
  overrideImage?: Maybe<BigIntFilter>;
  /** Filter by the object’s `special` field. */
  special?: Maybe<BooleanFilter>;
  /** Filter by the object’s `startsAt` field. */
  startsAt?: Maybe<DatetimeFilter>;
};

export type EventTag = {
  __typename?: 'EventTag';
  /** Reads and enables pagination through a set of `EventViaEventTag`. */
  events: EventViaEventTagsConnection;
  id: Scalars['BigInt'];
  image: Maybe<Scalars['BigInt']>;
  /** Reads a single `Image` that is related to this `EventTag`. */
  imageByImage: Maybe<Image>;
  img: ResponsiveImage;
  /** Reads and enables pagination through a set of `EventTagTr`. */
  translations: EventTagTrsConnection;
};


export type EventTagEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaEventTagCondition>;
  filter?: Maybe<EventViaEventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};


export type EventTagTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagTrCondition>;
  filter?: Maybe<EventTagTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};

/**
 * A condition to be used against `EventTag` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EventTagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `image` field. */
  image?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventTag` object types. All fields are combined with a logical ‘and.’ */
export type EventTagFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `image` field. */
  image?: Maybe<BigIntFilter>;
};

export type EventTagTr = {
  __typename?: 'EventTagTr';
  languageCode: TrLanguage;
  /** Reads a single `EventTag` that is related to this `EventTagTr`. */
  tag: Maybe<EventTag>;
  tagId: Scalars['BigInt'];
  title: Scalars['String'];
};

/**
 * A condition to be used against `EventTagTr` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EventTagTrCondition = {
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTagTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTagTrFilter = {
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** A connection to a list of `EventTagTr` values. */
export type EventTagTrsConnection = {
  __typename?: 'EventTagTrsConnection';
  /** A list of edges which contains the `EventTagTr` and cursor to aid in pagination. */
  edges: Array<EventTagTrsEdge>;
  /** A list of `EventTagTr` objects. */
  nodes: Array<EventTagTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTagTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTagTr` edge in the connection. */
export type EventTagTrsEdge = {
  __typename?: 'EventTagTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTagTr` at the end of the edge. */
  node: EventTagTr;
};

/** Methods to use when ordering `EventTagTr`. */
export enum EventTagTrsOrderBy {
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `EventTag` values. */
export type EventTagsConnection = {
  __typename?: 'EventTagsConnection';
  /** A list of edges which contains the `EventTag` and cursor to aid in pagination. */
  edges: Array<EventTagsEdge>;
  /** A list of `EventTag` objects. */
  nodes: Array<EventTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTag` edge in the connection. */
export type EventTagsEdge = {
  __typename?: 'EventTagsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTag` at the end of the edge. */
  node: EventTag;
};

/** Methods to use when ordering `EventTag`. */
export enum EventTagsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageAsc = 'IMAGE_ASC',
  ImageDesc = 'IMAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type EventTr = {
  __typename?: 'EventTr';
  description: Scalars['String'];
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  slug: Scalars['String'];
  title: Scalars['String'];
};

/** A condition to be used against `EventTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `EventTrDatum` */
export type EventTrDatumInput = {
  description: Scalars['String'];
  languageCode: Scalars['String'];
  title: Scalars['String'];
};

/** A filter to be used against `EventTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTrFilter = {
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** A connection to a list of `EventTr` values. */
export type EventTrsConnection = {
  __typename?: 'EventTrsConnection';
  /** A list of edges which contains the `EventTr` and cursor to aid in pagination. */
  edges: Array<EventTrsEdge>;
  /** A list of `EventTr` objects. */
  nodes: Array<EventTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTr` edge in the connection. */
export type EventTrsEdge = {
  __typename?: 'EventTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTr` at the end of the edge. */
  node: EventTr;
};

/** Methods to use when ordering `EventTr`. */
export enum EventTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export type EventViaEventTag = {
  __typename?: 'EventViaEventTag';
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
  tagId: Scalars['BigInt'];
};

/**
 * A condition to be used against `EventViaEventTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventViaEventTagCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventViaEventTag` object types. All fields are combined with a logical ‘and.’ */
export type EventViaEventTagFilter = {
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `tagId` field. */
  tagId?: Maybe<BigIntFilter>;
};

/** An input for mutations affecting `EventViaEventTag` */
export type EventViaEventTagInput = {
  eventId: Scalars['BigInt'];
  tagId: Scalars['BigInt'];
};

/** Represents an update to a `EventViaEventTag`. Fields that are set will be updated. */
export type EventViaEventTagPatch = {
  eventId?: Maybe<Scalars['BigInt']>;
  tagId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `EventViaEventTag` values. */
export type EventViaEventTagsConnection = {
  __typename?: 'EventViaEventTagsConnection';
  /** A list of edges which contains the `EventViaEventTag` and cursor to aid in pagination. */
  edges: Array<EventViaEventTagsEdge>;
  /** A list of `EventViaEventTag` objects. */
  nodes: Array<EventViaEventTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventViaEventTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventViaEventTag` edge in the connection. */
export type EventViaEventTagsEdge = {
  __typename?: 'EventViaEventTagsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventViaEventTag` at the end of the edge. */
  node: EventViaEventTag;
};

/** Methods to use when ordering `EventViaEventTag`. */
export enum EventViaEventTagsOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagIdAsc = 'TAG_ID_ASC',
  TagIdDesc = 'TAG_ID_DESC'
}

export type EventViaGroup = {
  __typename?: 'EventViaGroup';
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  groupId: Scalars['BigInt'];
};

/**
 * A condition to be used against `EventViaGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventViaGroupCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventViaGroup` object types. All fields are combined with a logical ‘and.’ */
export type EventViaGroupFilter = {
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
};

/** An input for mutations affecting `EventViaGroup` */
export type EventViaGroupInput = {
  eventId: Scalars['BigInt'];
  groupId: Scalars['BigInt'];
};

/** Represents an update to a `EventViaGroup`. Fields that are set will be updated. */
export type EventViaGroupPatch = {
  eventId?: Maybe<Scalars['BigInt']>;
  groupId?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `EventViaGroup` values. */
export type EventViaGroupsConnection = {
  __typename?: 'EventViaGroupsConnection';
  /** A list of edges which contains the `EventViaGroup` and cursor to aid in pagination. */
  edges: Array<EventViaGroupsEdge>;
  /** A list of `EventViaGroup` objects. */
  nodes: Array<EventViaGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventViaGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventViaGroup` edge in the connection. */
export type EventViaGroupsEdge = {
  __typename?: 'EventViaGroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventViaGroup` at the end of the edge. */
  node: EventViaGroup;
};

/** Methods to use when ordering `EventViaGroup`. */
export enum EventViaGroupsOrderBy {
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  EndsAtAsc = 'ENDS_AT_ASC',
  EndsAtDesc = 'ENDS_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsTemplateAsc = 'IS_TEMPLATE_ASC',
  IsTemplateDesc = 'IS_TEMPLATE_DESC',
  Natural = 'NATURAL',
  OverrideImageAsc = 'OVERRIDE_IMAGE_ASC',
  OverrideImageDesc = 'OVERRIDE_IMAGE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SpecialAsc = 'SPECIAL_ASC',
  SpecialDesc = 'SPECIAL_DESC',
  StartsAtAsc = 'STARTS_AT_ASC',
  StartsAtDesc = 'STARTS_AT_DESC'
}

export type Group = {
  __typename?: 'Group';
  /** Reads and enables pagination through a set of `EventViaGroup`. */
  events: EventViaGroupsConnection;
  id: Scalars['BigInt'];
  image: Maybe<Scalars['BigInt']>;
  /** Reads a single `Image` that is related to this `Group`. */
  imageByImage: Maybe<Image>;
  img: ResponsiveImage;
  /** Reads and enables pagination through a set of `GroupTr`. */
  translations: GroupTrsConnection;
};


export type GroupEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventViaGroupCondition>;
  filter?: Maybe<EventViaGroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};


export type GroupTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `image` field. */
  image?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `image` field. */
  image?: Maybe<BigIntFilter>;
};

export type GroupTr = {
  __typename?: 'GroupTr';
  description: Scalars['String'];
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  shortDescription: Scalars['String'];
  slug: Scalars['String'];
  title: Scalars['String'];
};

/** A condition to be used against `GroupTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `GroupTr` object types. All fields are combined with a logical ‘and.’ */
export type GroupTrFilter = {
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** A connection to a list of `GroupTr` values. */
export type GroupTrsConnection = {
  __typename?: 'GroupTrsConnection';
  /** A list of edges which contains the `GroupTr` and cursor to aid in pagination. */
  edges: Array<GroupTrsEdge>;
  /** A list of `GroupTr` objects. */
  nodes: Array<GroupTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GroupTr` edge in the connection. */
export type GroupTrsEdge = {
  __typename?: 'GroupTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GroupTr` at the end of the edge. */
  node: GroupTr;
};

/** Methods to use when ordering `GroupTr`. */
export enum GroupTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageAsc = 'IMAGE_ASC',
  ImageDesc = 'IMAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Image = {
  __typename?: 'Image';
  /** Reads and enables pagination through a set of `EventTag`. */
  eventTagsByImage: EventTagsConnection;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByOverrideImage: EventsConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByImage: GroupsConnection;
  height: Scalars['Int'];
  id: Scalars['BigInt'];
  path: Scalars['String'];
  /** Reads and enables pagination through a set of `Picture`. */
  picturesByImage: PicturesConnection;
  width: Scalars['Int'];
};


export type ImageEventTagsByImageArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagCondition>;
  filter?: Maybe<EventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};


export type ImageEventsByOverrideImageArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


export type ImageGroupsByImageArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type ImagePicturesByImageArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PictureCondition>;
  filter?: Maybe<PictureFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PicturesOrderBy>>;
};

/** A condition to be used against `Image` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ImageCondition = {
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `path` field. */
  path?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `width` field. */
  width?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `Image` object types. All fields are combined with a logical ‘and.’ */
export type ImageFilter = {
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `path` field. */
  path?: Maybe<StringFilter>;
  /** Filter by the object’s `width` field. */
  width?: Maybe<IntFilter>;
};

/** An input for mutations affecting `Image` */
export type ImageInput = {
  height: Scalars['Int'];
  id?: Maybe<Scalars['BigInt']>;
  path: Scalars['String'];
  width: Scalars['Int'];
};

/** Represents an update to a `Image`. Fields that are set will be updated. */
export type ImagePatch = {
  height?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['BigInt']>;
  path?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `Image` values. */
export type ImagesConnection = {
  __typename?: 'ImagesConnection';
  /** A list of edges which contains the `Image` and cursor to aid in pagination. */
  edges: Array<ImagesEdge>;
  /** A list of `Image` objects. */
  nodes: Array<Image>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Image` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Image` edge in the connection. */
export type ImagesEdge = {
  __typename?: 'ImagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Image` at the end of the edge. */
  node: Image;
};

/** Methods to use when ordering `Image`. */
export enum ImagesOrderBy {
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
};

export type Member = {
  __typename?: 'Member';
  id: Scalars['UUID'];
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Member` object types. All fields are combined with a logical ‘and.’ */
export type MemberFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
};

/** An input for mutations affecting `Member` */
export type MemberInput = {
  id?: Maybe<Scalars['UUID']>;
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** Represents an update to a `Member`. Fields that are set will be updated. */
export type MemberPatch = {
  id?: Maybe<Scalars['UUID']>;
  isActive?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  authenticate: Scalars['String'];
  /** Creates a single `EventViaEventTag`. */
  createEventViaEventTag: Maybe<CreateEventViaEventTagPayload>;
  /** Creates a single `EventViaGroup`. */
  createEventViaGroup: Maybe<CreateEventViaGroupPayload>;
  /** Creates a single `Image`. */
  createImage: Maybe<CreateImagePayload>;
  /** Creates a single `Member`. */
  createMember: Maybe<CreateMemberPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `PageTr`. */
  createPageTr: Maybe<CreatePageTrPayload>;
  /** Creates a single `Picture`. */
  createPicture: Maybe<CreatePicturePayload>;
  /** Get a signed URL for uploading files. It will expire in 5 minutes. */
  createUploadUrl: Maybe<CreateUploadUrlPayload>;
  /** Deletes a single `EventViaEventTag` using a unique key. */
  deleteEventViaEventTag: Maybe<DeleteEventViaEventTagPayload>;
  /** Deletes a single `EventViaGroup` using a unique key. */
  deleteEventViaGroup: Maybe<DeleteEventViaGroupPayload>;
  /** Deletes a single `Image` using a unique key. */
  deleteImage: Maybe<DeleteImagePayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMember: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMemberByUsername: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Page` using a unique key. */
  deletePage: Maybe<DeletePagePayload>;
  /** Deletes a single `PageTr` using a unique key. */
  deletePageTr: Maybe<DeletePageTrPayload>;
  /** Deletes a single `Picture` using a unique key. */
  deletePicture: Maybe<DeletePicturePayload>;
  logout: Maybe<Scalars['Boolean']>;
  reorderPictures: Maybe<ReorderPicturesPayload>;
  /** Updates a single `EventViaEventTag` using a unique key and a patch. */
  updateEventViaEventTag: Maybe<UpdateEventViaEventTagPayload>;
  /** Updates a single `EventViaGroup` using a unique key and a patch. */
  updateEventViaGroup: Maybe<UpdateEventViaGroupPayload>;
  /** Updates a single `Image` using a unique key and a patch. */
  updateImage: Maybe<UpdateImagePayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMember: Maybe<UpdateMemberPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMemberByUsername: Maybe<UpdateMemberPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `PageTr` using a unique key and a patch. */
  updatePageTr: Maybe<UpdatePageTrPayload>;
  /** Updates a single `Picture` using a unique key and a patch. */
  updatePicture: Maybe<UpdatePicturePayload>;
  upsertEvent: Maybe<UpsertEventPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAuthenticateArgs = {
  input: AuthenticateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventViaEventTagArgs = {
  input: CreateEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventViaGroupArgs = {
  input: CreateEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateImageArgs = {
  input: CreateImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMemberArgs = {
  input: CreateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageTrArgs = {
  input: CreatePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePictureArgs = {
  input: CreatePictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUploadUrlArgs = {
  input: CreateUploadUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventViaEventTagArgs = {
  input: DeleteEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventViaGroupArgs = {
  input: DeleteEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteImageArgs = {
  input: DeleteImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberArgs = {
  input: DeleteMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberByUsernameArgs = {
  input: DeleteMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageArgs = {
  input: DeletePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageTrArgs = {
  input: DeletePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePictureArgs = {
  input: DeletePictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationReorderPicturesArgs = {
  input: ReorderPicturesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventViaEventTagArgs = {
  input: UpdateEventViaEventTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventViaGroupArgs = {
  input: UpdateEventViaGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateImageArgs = {
  input: UpdateImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberByUsernameArgs = {
  input: UpdateMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageTrArgs = {
  input: UpdatePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePictureArgs = {
  input: UpdatePictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertEventArgs = {
  input: UpsertEventInput;
};

export type Page = {
  __typename?: 'Page';
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `PageTr`. */
  translations: PageTrsConnection;
};


export type PageTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Page` object types. All fields are combined with a logical ‘and.’ */
export type PageFilter = {
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  name: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  name?: Maybe<Scalars['String']>;
};

export type PageTr = {
  __typename?: 'PageTr';
  content: Scalars['String'];
  languageCode: TrLanguage;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  pageName: Scalars['String'];
};

/** A condition to be used against `PageTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageTrCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `pageName` field. */
  pageName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PageTr` object types. All fields are combined with a logical ‘and.’ */
export type PageTrFilter = {
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Filter by the object’s `pageName` field. */
  pageName?: Maybe<StringFilter>;
};

/** An input for mutations affecting `PageTr` */
export type PageTrInput = {
  content: Scalars['String'];
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** Represents an update to a `PageTr`. Fields that are set will be updated. */
export type PageTrPatch = {
  content?: Maybe<Scalars['String']>;
  languageCode?: Maybe<TrLanguage>;
  pageName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PageTr` values. */
export type PageTrsConnection = {
  __typename?: 'PageTrsConnection';
  /** A list of edges which contains the `PageTr` and cursor to aid in pagination. */
  edges: Array<PageTrsEdge>;
  /** A list of `PageTr` objects. */
  nodes: Array<PageTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageTr` edge in the connection. */
export type PageTrsEdge = {
  __typename?: 'PageTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageTr` at the end of the edge. */
  node: PageTr;
};

/** Methods to use when ordering `PageTr`. */
export enum PageTrsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PageNameAsc = 'PAGE_NAME_ASC',
  PageNameDesc = 'PAGE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export enum PagesOrderBy {
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Picture = {
  __typename?: 'Picture';
  allowOnHome: Scalars['Boolean'];
  id: Scalars['BigInt'];
  image: Scalars['BigInt'];
  /** Reads a single `Image` that is related to this `Picture`. */
  imageByImage: Maybe<Image>;
  img: ResponsiveImage;
  rank: Scalars['Int'];
};

/** A condition to be used against `Picture` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PictureCondition = {
  /** Checks for equality with the object’s `allowOnHome` field. */
  allowOnHome?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `image` field. */
  image?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `rank` field. */
  rank?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `Picture` object types. All fields are combined with a logical ‘and.’ */
export type PictureFilter = {
  /** Filter by the object’s `allowOnHome` field. */
  allowOnHome?: Maybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `image` field. */
  image?: Maybe<BigIntFilter>;
  /** Filter by the object’s `rank` field. */
  rank?: Maybe<IntFilter>;
};

/** An input for mutations affecting `Picture` */
export type PictureInput = {
  allowOnHome?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['BigInt']>;
  image: Scalars['BigInt'];
  rank?: Maybe<Scalars['Int']>;
};

/** Represents an update to a `Picture`. Fields that are set will be updated. */
export type PicturePatch = {
  allowOnHome?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['BigInt']>;
  image?: Maybe<Scalars['BigInt']>;
  rank?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `Picture` values. */
export type PicturesConnection = {
  __typename?: 'PicturesConnection';
  /** A list of edges which contains the `Picture` and cursor to aid in pagination. */
  edges: Array<PicturesEdge>;
  /** A list of `Picture` objects. */
  nodes: Array<Picture>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Picture` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Picture` edge in the connection. */
export type PicturesEdge = {
  __typename?: 'PicturesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Picture` at the end of the edge. */
  node: Picture;
};

/** Methods to use when ordering `Picture`. */
export enum PicturesOrderBy {
  AllowOnHomeAsc = 'ALLOW_ON_HOME_ASC',
  AllowOnHomeDesc = 'ALLOW_ON_HOME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageAsc = 'IMAGE_ASC',
  ImageDesc = 'IMAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RankAsc = 'RANK_ASC',
  RankDesc = 'RANK_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  currentMember: Maybe<Member>;
  event: Maybe<Event>;
  eventBySlug: Maybe<Event>;
  eventImage: Maybe<Scalars['Int']>;
  eventTag: Maybe<EventTag>;
  eventTagTr: Maybe<EventTagTr>;
  /** Reads and enables pagination through a set of `EventTagTr`. */
  eventTagTrs: Maybe<EventTagTrsConnection>;
  /** Reads and enables pagination through a set of `EventTag`. */
  eventTags: Maybe<EventTagsConnection>;
  eventTr: Maybe<EventTr>;
  eventTrBySlugAndLanguageCode: Maybe<EventTr>;
  /** Reads and enables pagination through a set of `EventTr`. */
  eventTrs: Maybe<EventTrsConnection>;
  eventViaEventTag: Maybe<EventViaEventTag>;
  eventViaGroup: Maybe<EventViaGroup>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  group: Maybe<Group>;
  groupBySlug: Maybe<Group>;
  groupTr: Maybe<GroupTr>;
  groupTrBySlugAndLanguageCode: Maybe<GroupTr>;
  /** Reads and enables pagination through a set of `GroupTr`. */
  groupTrs: Maybe<GroupTrsConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: Maybe<GroupsConnection>;
  image: Maybe<Image>;
  /** Reads and enables pagination through a set of `Image`. */
  images: Maybe<ImagesConnection>;
  member: Maybe<Member>;
  memberByUsername: Maybe<Member>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  page: Maybe<Page>;
  pageTr: Maybe<PageTr>;
  /** Reads and enables pagination through a set of `PageTr`. */
  pageTrs: Maybe<PageTrsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  picture: Maybe<Picture>;
  /** Reads and enables pagination through a set of `Picture`. */
  pictures: Maybe<PicturesConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads and enables pagination through a set of `Picture`. */
  randomPictures: Maybe<PicturesConnection>;
  /** Reads and enables pagination through a set of `EventTag`. */
  searchEventTags: Maybe<EventTagsConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  searchGroups: Maybe<GroupsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventBySlugArgs = {
  preferredLanguageCode: Scalars['String'];
  slug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventImageArgs = {
  eid: Scalars['Int'];
  overrideImage: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagTrArgs = {
  languageCode: TrLanguage;
  tagId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagTrCondition>;
  filter?: Maybe<EventTagTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTagsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTagCondition>;
  filter?: Maybe<EventTagFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrArgs = {
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrBySlugAndLanguageCodeArgs = {
  languageCode: TrLanguage;
  slug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventViaEventTagArgs = {
  eventId: Scalars['BigInt'];
  tagId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventViaGroupArgs = {
  eventId: Scalars['BigInt'];
  groupId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupBySlugArgs = {
  preferredLanguageCode: Scalars['String'];
  slug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrArgs = {
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrBySlugAndLanguageCodeArgs = {
  languageCode: TrLanguage;
  slug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryImageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryImagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ImageCondition>;
  filter?: Maybe<ImageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberByUsernameArgs = {
  username: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MemberCondition>;
  filter?: Maybe<MemberFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrArgs = {
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageCondition>;
  filter?: Maybe<PageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPictureArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPicturesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PictureCondition>;
  filter?: Maybe<PictureFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PicturesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRandomPicturesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySearchEventTagsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  query: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySearchGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  query: Scalars['String'];
};

/** All input for the `reorderPictures` mutation. */
export type ReorderPicturesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  reorders: Array<Maybe<ReorderPicturesReorderInput>>;
};

/** The output of our `reorderPictures` mutation. */
export type ReorderPicturesPayload = {
  __typename?: 'ReorderPicturesPayload';
  boolean: Maybe<Scalars['Boolean']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** An input for mutations affecting `ReorderPicturesReorder` */
export type ReorderPicturesReorderInput = {
  fromRank?: Maybe<Scalars['Int']>;
  toRank?: Maybe<Scalars['Int']>;
};

export type ResponsiveImage = {
  __typename?: 'ResponsiveImage';
  height: Scalars['Int'];
  src: Scalars['String'];
  srcSetJpeg: Scalars['String'];
  srcSetWebp: Scalars['String'];
  width: Scalars['Int'];
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
};

export enum TrLanguage {
  Da = 'DA',
  En = 'EN'
}

/** A filter to be used against TrLanguage fields. All fields are combined with a logical ‘and.’ */
export type TrLanguageFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<TrLanguage>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TrLanguage>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TrLanguage>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<TrLanguage>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TrLanguage>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TrLanguage>;
};


/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
};

/** All input for the `updateEventViaEventTag` mutation. */
export type UpdateEventViaEventTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventViaEventTag` being updated. */
  patch: EventViaEventTagPatch;
  tagId: Scalars['BigInt'];
};

/** The output of our update `EventViaEventTag` mutation. */
export type UpdateEventViaEventTagPayload = {
  __typename?: 'UpdateEventViaEventTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaEventTag`. */
  event: Maybe<Event>;
  /** The `EventViaEventTag` that was updated by this mutation. */
  eventViaEventTag: Maybe<EventViaEventTag>;
  /** An edge for our `EventViaEventTag`. May be used by Relay 1. */
  eventViaEventTagEdge: Maybe<EventViaEventTagsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `EventTag` that is related to this `EventViaEventTag`. */
  tag: Maybe<EventTag>;
};


/** The output of our update `EventViaEventTag` mutation. */
export type UpdateEventViaEventTagPayloadEventViaEventTagEdgeArgs = {
  orderBy?: Maybe<Array<EventViaEventTagsOrderBy>>;
};

/** All input for the `updateEventViaGroup` mutation. */
export type UpdateEventViaGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  groupId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventViaGroup` being updated. */
  patch: EventViaGroupPatch;
};

/** The output of our update `EventViaGroup` mutation. */
export type UpdateEventViaGroupPayload = {
  __typename?: 'UpdateEventViaGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventViaGroup`. */
  event: Maybe<Event>;
  /** The `EventViaGroup` that was updated by this mutation. */
  eventViaGroup: Maybe<EventViaGroup>;
  /** An edge for our `EventViaGroup`. May be used by Relay 1. */
  eventViaGroupEdge: Maybe<EventViaGroupsEdge>;
  /** Reads a single `Group` that is related to this `EventViaGroup`. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventViaGroup` mutation. */
export type UpdateEventViaGroupPayloadEventViaGroupEdgeArgs = {
  orderBy?: Maybe<Array<EventViaGroupsOrderBy>>;
};

/** All input for the `updateImage` mutation. */
export type UpdateImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Image` being updated. */
  patch: ImagePatch;
};

/** The output of our update `Image` mutation. */
export type UpdateImagePayload = {
  __typename?: 'UpdateImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Image` that was updated by this mutation. */
  image: Maybe<Image>;
  /** An edge for our `Image`. May be used by Relay 1. */
  imageEdge: Maybe<ImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Image` mutation. */
export type UpdateImagePayloadImageEdgeArgs = {
  orderBy?: Maybe<Array<ImagesOrderBy>>;
};

/** All input for the `updateMemberByUsername` mutation. */
export type UpdateMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
  username: Scalars['String'];
};

/** All input for the `updateMember` mutation. */
export type UpdateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
};

/** The output of our update `Member` mutation. */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was updated by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Member` mutation. */
export type UpdateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `updatePageTr` mutation. */
export type UpdatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
  /** An object where the defined keys will be set on the `PageTr` being updated. */
  patch: PageTrPatch;
};

/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayload = {
  __typename?: 'UpdatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was updated by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** All input for the `updatePicture` mutation. */
export type UpdatePictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Picture` being updated. */
  patch: PicturePatch;
};

/** The output of our update `Picture` mutation. */
export type UpdatePicturePayload = {
  __typename?: 'UpdatePicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Image` that is related to this `Picture`. */
  imageByImage: Maybe<Image>;
  /** The `Picture` that was updated by this mutation. */
  picture: Maybe<Picture>;
  /** An edge for our `Picture`. May be used by Relay 1. */
  pictureEdge: Maybe<PicturesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Picture` mutation. */
export type UpdatePicturePayloadPictureEdgeArgs = {
  orderBy?: Maybe<Array<PicturesOrderBy>>;
};

/** All input for the `upsertEvent` mutation. */
export type UpsertEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  data: EventDatumInput;
  eventId?: Maybe<Scalars['BigInt']>;
  translations: Array<Maybe<EventTrDatumInput>>;
};

/** The output of our `upsertEvent` mutation. */
export type UpsertEventPayload = {
  __typename?: 'UpsertEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Reads a single `Image` that is related to this `Event`. */
  imageByOverrideImage: Maybe<Image>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `upsertEvent` mutation. */
export type UpsertEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

export type AuthenticateMutationVariables = Exact<{
  username: Scalars['String'];
  password: Scalars['String'];
}>;


export type AuthenticateMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'authenticate'>
);

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'logout'>
);

export type GetMeQueryVariables = Exact<{ [key: string]: never; }>;


export type GetMeQuery = (
  { __typename?: 'Query' }
  & { currentMember: Maybe<(
    { __typename?: 'Member' }
    & Pick<Member, 'name' | 'id' | 'userRole'>
  )> }
);

export type SearchGroupsQueryVariables = Exact<{
  query: Scalars['String'];
}>;


export type SearchGroupsQuery = (
  { __typename?: 'Query' }
  & { searchGroups: Maybe<(
    { __typename?: 'GroupsConnection' }
    & { nodes: Array<(
      { __typename?: 'Group' }
      & Pick<Group, 'id'>
      & { translations: (
        { __typename?: 'GroupTrsConnection' }
        & { nodes: Array<(
          { __typename?: 'GroupTr' }
          & Pick<GroupTr, 'title' | 'groupId' | 'languageCode'>
        )> }
      ) }
    )> }
  )> }
);

export type SearchEventTagsQueryVariables = Exact<{
  query: Scalars['String'];
}>;


export type SearchEventTagsQuery = (
  { __typename?: 'Query' }
  & { searchEventTags: Maybe<(
    { __typename?: 'EventTagsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTag' }
      & Pick<EventTag, 'id'>
      & { translations: (
        { __typename?: 'EventTagTrsConnection' }
        & { nodes: Array<(
          { __typename?: 'EventTagTr' }
          & Pick<EventTagTr, 'languageCode' | 'title' | 'tagId'>
        )> }
      ) }
    )> }
  )> }
);

export type GroupByIdQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type GroupByIdQuery = (
  { __typename?: 'Query' }
  & { group: Maybe<(
    { __typename?: 'Group' }
    & Pick<Group, 'id'>
    & { translations: (
      { __typename?: 'GroupTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'GroupTr' }
        & Pick<GroupTr, 'languageCode' | 'title' | 'groupId'>
      )> }
    ) }
  )> }
);

export type EventTagByIdQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type EventTagByIdQuery = (
  { __typename?: 'Query' }
  & { eventTag: Maybe<(
    { __typename?: 'EventTag' }
    & Pick<EventTag, 'id'>
    & { translations: (
      { __typename?: 'EventTagTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'EventTagTr' }
        & Pick<EventTagTr, 'languageCode' | 'title' | 'tagId'>
      )> }
    ) }
  )> }
);

export type CalendarEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
  startsBefore?: Maybe<Scalars['Datetime']>;
}>;


export type CalendarEventsQueryQuery = (
  { __typename?: 'Query' }
  & { events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & CalendarEventFragment
    )> }
  )> }
);

export type CalendarEventFragment = (
  { __typename?: 'Event' }
  & Pick<Event, 'endsAt' | 'id' | 'startsAt'>
  & { translations: (
    { __typename?: 'EventTrsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTr' }
      & Pick<EventTr, 'slug' | 'title' | 'languageCode' | 'eventId'>
    )> }
  ) }
);

export type CalendarEventBySlugQueryVariables = Exact<{
  languageCode: Scalars['String'];
  slug: Scalars['String'];
}>;


export type CalendarEventBySlugQuery = (
  { __typename?: 'Query' }
  & { eventBySlug: Maybe<(
    { __typename?: 'Event' }
    & Pick<Event, 'startsAt' | 'endsAt' | 'id'>
    & { translations: (
      { __typename?: 'EventTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'EventTr' }
        & Pick<EventTr, 'description' | 'eventId' | 'languageCode' | 'slug' | 'title'>
      )> }
    ), img: Maybe<(
      { __typename?: 'ResponsiveImage' }
      & Pick<ResponsiveImage, 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'height' | 'width'>
    )>, tags: (
      { __typename?: 'EventViaEventTagsConnection' }
      & { nodes: Array<(
        { __typename?: 'EventViaEventTag' }
        & Pick<EventViaEventTag, 'eventId' | 'tagId'>
        & { tag: Maybe<(
          { __typename?: 'EventTag' }
          & Pick<EventTag, 'id'>
          & { translations: (
            { __typename?: 'EventTagTrsConnection' }
            & { nodes: Array<(
              { __typename?: 'EventTagTr' }
              & Pick<EventTagTr, 'languageCode' | 'tagId' | 'title'>
            )> }
          ) }
        )> }
      )> }
    ), groups: (
      { __typename?: 'EventViaGroupsConnection' }
      & { nodes: Array<(
        { __typename?: 'EventViaGroup' }
        & Pick<EventViaGroup, 'eventId' | 'groupId'>
        & { group: Maybe<(
          { __typename?: 'Group' }
          & Pick<Group, 'id'>
          & { translations: (
            { __typename?: 'GroupTrsConnection' }
            & { nodes: Array<(
              { __typename?: 'GroupTr' }
              & Pick<GroupTr, 'groupId' | 'languageCode' | 'title'>
            )> }
          ) }
        )> }
      )> }
    ) }
  )> }
);

export type UpsertEventMutationVariables = Exact<{
  data: EventDatumInput;
  translations: Array<Maybe<EventTrDatumInput>> | Maybe<EventTrDatumInput>;
  id?: Maybe<Scalars['BigInt']>;
}>;


export type UpsertEventMutation = (
  { __typename?: 'Mutation' }
  & { upsertEvent: Maybe<(
    { __typename?: 'UpsertEventPayload' }
    & { event: Maybe<(
      { __typename?: 'Event' }
      & CalendarEventFragment
    )> }
  )> }
);

export type GetUploadUrlMutationVariables = Exact<{
  contentType: Scalars['String'];
  randomId?: Maybe<Scalars['String']>;
}>;


export type GetUploadUrlMutation = (
  { __typename?: 'Mutation' }
  & { createUploadUrl: Maybe<(
    { __typename?: 'CreateUploadUrlPayload' }
    & Pick<CreateUploadUrlPayload, 'uploadUrl' | 'formData'>
  )> }
);

export type HomeEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
}>;


export type HomeEventsQueryQuery = (
  { __typename?: 'Query' }
  & { specialEvents: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & { img: Maybe<(
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'height' | 'width'>
      )> }
      & HomeEventFragment
    )> }
  )>, events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & HomeEventFragment
    )> }
  )> }
);

export type HomeEventFragment = (
  { __typename?: 'Event' }
  & Pick<Event, 'endsAt' | 'id' | 'startsAt' | 'special'>
  & { translations: (
    { __typename?: 'EventTrsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTr' }
      & Pick<EventTr, 'slug' | 'title' | 'languageCode' | 'description' | 'eventId'>
    )> }
  ) }
);

export type HomeGroupsQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeGroupsQueryQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<(
    { __typename?: 'GroupsConnection' }
    & { nodes: Array<(
      { __typename?: 'Group' }
      & Pick<Group, 'id'>
      & { img: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'height' | 'width'>
      ), translations: (
        { __typename?: 'GroupTrsConnection' }
        & { nodes: Array<(
          { __typename?: 'GroupTr' }
          & Pick<GroupTr, 'languageCode' | 'title' | 'shortDescription' | 'slug' | 'groupId'>
        )> }
      ) }
    )> }
  )> }
);

export type HomeRandomPicturesQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeRandomPicturesQueryQuery = (
  { __typename?: 'Query' }
  & { randomPictures: Maybe<(
    { __typename?: 'PicturesConnection' }
    & { nodes: Array<(
      { __typename?: 'Picture' }
      & Pick<Picture, 'image' | 'id' | 'rank'>
      & { img: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'height' | 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'width'>
      ) }
    )> }
  )> }
);

export type PageQueryQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type PageQueryQuery = (
  { __typename?: 'Query' }
  & { page: Maybe<(
    { __typename?: 'Page' }
    & Pick<Page, 'name'>
    & { translations: (
      { __typename?: 'PageTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'PageTr' }
        & PageTranslationFragment
      )> }
    ) }
  )> }
);

export type UpdatePageTranslationMutationVariables = Exact<{
  content: Scalars['String'];
  pageName: Scalars['String'];
  languageCode: TrLanguage;
}>;


export type UpdatePageTranslationMutation = (
  { __typename?: 'Mutation' }
  & { updatePageTr: Maybe<(
    { __typename?: 'UpdatePageTrPayload' }
    & { pageTr: Maybe<(
      { __typename?: 'PageTr' }
      & PageTranslationFragment
    )> }
  )> }
);

export type PageTranslationFragment = (
  { __typename?: 'PageTr' }
  & Pick<PageTr, 'content' | 'languageCode' | 'pageName'>
);

export type PicturesQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type PicturesQueryQuery = (
  { __typename?: 'Query' }
  & { pictures: Maybe<(
    { __typename?: 'PicturesConnection' }
    & { nodes: Array<(
      { __typename?: 'Picture' }
      & Pick<Picture, 'id' | 'rank' | 'allowOnHome'>
      & { img: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'height' | 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'width'>
      ) }
    )> }
  )> }
);

export type CreateImageMutationMutationVariables = Exact<{
  path: Scalars['String'];
  height: Scalars['Int'];
  width: Scalars['Int'];
}>;


export type CreateImageMutationMutation = (
  { __typename?: 'Mutation' }
  & { createImage: Maybe<(
    { __typename?: 'CreateImagePayload' }
    & { image: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'id'>
    )> }
  )> }
);

export type CreatePictureMutationVariables = Exact<{
  image: Scalars['BigInt'];
}>;


export type CreatePictureMutation = (
  { __typename?: 'Mutation' }
  & { createPicture: Maybe<(
    { __typename?: 'CreatePicturePayload' }
    & { picture: Maybe<(
      { __typename?: 'Picture' }
      & Pick<Picture, 'id' | 'rank' | 'allowOnHome'>
      & { img: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'height' | 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'width'>
      ) }
    )> }
  )> }
);

export type ReorderPicturesMutationMutationVariables = Exact<{
  reorders: Array<Maybe<ReorderPicturesReorderInput>> | Maybe<ReorderPicturesReorderInput>;
}>;


export type ReorderPicturesMutationMutation = (
  { __typename?: 'Mutation' }
  & { reorderPictures: Maybe<(
    { __typename?: 'ReorderPicturesPayload' }
    & Pick<ReorderPicturesPayload, 'boolean'>
  )> }
);

export type SetPictureAllowOnHomeMutationMutationVariables = Exact<{
  id: Scalars['BigInt'];
  input: Scalars['Boolean'];
}>;


export type SetPictureAllowOnHomeMutationMutation = (
  { __typename?: 'Mutation' }
  & { updatePicture: Maybe<(
    { __typename?: 'UpdatePicturePayload' }
    & { picture: Maybe<(
      { __typename?: 'Picture' }
      & Pick<Picture, 'image' | 'id' | 'rank' | 'allowOnHome'>
      & { img: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'height' | 'src' | 'srcSetJpeg' | 'srcSetWebp' | 'width'>
      ) }
    )> }
  )> }
);

export const CalendarEventFragmentDoc = gql`
    fragment CalendarEvent on Event {
  translations {
    nodes {
      slug
      title
      languageCode
      eventId
    }
  }
  endsAt
  id
  startsAt
}
    ` as unknown as DocumentNode<CalendarEventFragment, unknown>;
export const HomeEventFragmentDoc = gql`
    fragment HomeEvent on Event {
  translations {
    nodes {
      slug
      title
      languageCode
      description
      eventId
    }
  }
  endsAt
  id
  startsAt
  special
}
    ` as unknown as DocumentNode<HomeEventFragment, unknown>;
export const PageTranslationFragmentDoc = gql`
    fragment PageTranslation on PageTr {
  content
  languageCode
  pageName
}
    ` as unknown as DocumentNode<PageTranslationFragment, unknown>;
export const AuthenticateDocument = gql`
    mutation Authenticate($username: String!, $password: String!) {
  authenticate(input: {username: $username, password: $password})
}
    ` as unknown as DocumentNode<AuthenticateMutation, AuthenticateMutationVariables>;
export const LogoutDocument = gql`
    mutation Logout {
  logout
}
    ` as unknown as DocumentNode<LogoutMutation, LogoutMutationVariables>;
export const GetMeDocument = gql`
    query GetMe {
  currentMember {
    name
    id
    userRole
  }
}
    ` as unknown as DocumentNode<GetMeQuery, GetMeQueryVariables>;
export const SearchGroupsDocument = gql`
    query SearchGroups($query: String!) {
  searchGroups(query: $query) {
    nodes {
      id
      translations {
        nodes {
          title
          groupId
          languageCode
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<SearchGroupsQuery, SearchGroupsQueryVariables>;
export const SearchEventTagsDocument = gql`
    query SearchEventTags($query: String!) {
  searchEventTags(query: $query) {
    nodes {
      id
      translations {
        nodes {
          languageCode
          title
          tagId
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<SearchEventTagsQuery, SearchEventTagsQueryVariables>;
export const GroupByIdDocument = gql`
    query GroupById($id: BigInt!) {
  group(id: $id) {
    id
    translations {
      nodes {
        languageCode
        title
        groupId
      }
    }
  }
}
    ` as unknown as DocumentNode<GroupByIdQuery, GroupByIdQueryVariables>;
export const EventTagByIdDocument = gql`
    query EventTagById($id: BigInt!) {
  eventTag(id: $id) {
    id
    translations {
      nodes {
        languageCode
        title
        tagId
      }
    }
  }
}
    ` as unknown as DocumentNode<EventTagByIdQuery, EventTagByIdQueryVariables>;
export const CalendarEventsQueryDocument = gql`
    query CalendarEventsQuery($startsAfter: Datetime, $startsBefore: Datetime) {
  events(
    filter: {startsAt: {greaterThan: $startsAfter, lessThan: $startsBefore}}
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...CalendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}` as unknown as DocumentNode<CalendarEventsQueryQuery, CalendarEventsQueryQueryVariables>;
export const CalendarEventBySlugDocument = gql`
    query CalendarEventBySlug($languageCode: String!, $slug: String!) {
  eventBySlug(preferredLanguageCode: $languageCode, slug: $slug) {
    translations {
      nodes {
        description
        eventId
        languageCode
        slug
        title
      }
    }
    startsAt
    img {
      src
      srcSetJpeg
      srcSetWebp
      height
      width
    }
    endsAt
    id
    tags {
      nodes {
        tag {
          id
          translations {
            nodes {
              languageCode
              tagId
              title
            }
          }
        }
        eventId
        tagId
      }
    }
    groups {
      nodes {
        group {
          id
          translations {
            nodes {
              groupId
              languageCode
              title
            }
          }
        }
        eventId
        groupId
      }
    }
  }
}
    ` as unknown as DocumentNode<CalendarEventBySlugQuery, CalendarEventBySlugQueryVariables>;
export const UpsertEventDocument = gql`
    mutation UpsertEvent($data: EventDatumInput!, $translations: [EventTrDatumInput]!, $id: BigInt) {
  upsertEvent(input: {data: $data, translations: $translations, eventId: $id}) {
    event {
      ...CalendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}` as unknown as DocumentNode<UpsertEventMutation, UpsertEventMutationVariables>;
export const GetUploadUrlDocument = gql`
    mutation GetUploadUrl($contentType: String!, $randomId: String) {
  createUploadUrl(input: {contentType: $contentType, clientMutationId: $randomId}) {
    uploadUrl
    formData
  }
}
    ` as unknown as DocumentNode<GetUploadUrlMutation, GetUploadUrlMutationVariables>;
export const HomeEventsQueryDocument = gql`
    query HomeEventsQuery($startsAfter: Datetime) {
  specialEvents: events(
    filter: {special: {equalTo: true}, startsAt: {greaterThan: $startsAfter}}
    condition: {isTemplate: false}
    first: 1
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...HomeEvent
      img {
        src
        srcSetJpeg
        srcSetWebp
        height
        width
      }
    }
  }
  events(
    filter: {startsAt: {greaterThan: $startsAfter}}
    condition: {isTemplate: false}
    first: 10
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...HomeEvent
    }
  }
}
    ${HomeEventFragmentDoc}` as unknown as DocumentNode<HomeEventsQueryQuery, HomeEventsQueryQueryVariables>;
export const HomeGroupsQueryDocument = gql`
    query HomeGroupsQuery {
  groups {
    nodes {
      id
      img {
        src
        srcSetJpeg
        srcSetWebp
        height
        width
      }
      translations {
        nodes {
          languageCode
          title
          shortDescription
          slug
          groupId
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<HomeGroupsQueryQuery, HomeGroupsQueryQueryVariables>;
export const HomeRandomPicturesQueryDocument = gql`
    query HomeRandomPicturesQuery {
  randomPictures(first: 4) {
    nodes {
      image
      id
      rank
      img {
        height
        src
        srcSetJpeg
        srcSetWebp
        width
      }
    }
  }
}
    ` as unknown as DocumentNode<HomeRandomPicturesQueryQuery, HomeRandomPicturesQueryQueryVariables>;
export const PageQueryDocument = gql`
    query PageQuery($name: String!) {
  page(name: $name) {
    name
    translations {
      nodes {
        ...PageTranslation
      }
    }
  }
}
    ${PageTranslationFragmentDoc}` as unknown as DocumentNode<PageQueryQuery, PageQueryQueryVariables>;
export const UpdatePageTranslationDocument = gql`
    mutation UpdatePageTranslation($content: String!, $pageName: String!, $languageCode: TrLanguage!) {
  updatePageTr(
    input: {patch: {content: $content}, pageName: $pageName, languageCode: $languageCode}
  ) {
    pageTr {
      ...PageTranslation
    }
  }
}
    ${PageTranslationFragmentDoc}` as unknown as DocumentNode<UpdatePageTranslationMutation, UpdatePageTranslationMutationVariables>;
export const PicturesQueryDocument = gql`
    query PicturesQuery {
  pictures(orderBy: RANK_ASC) {
    nodes {
      img {
        height
        src
        srcSetJpeg
        srcSetWebp
        width
      }
      id
      rank
      allowOnHome
    }
  }
}
    ` as unknown as DocumentNode<PicturesQueryQuery, PicturesQueryQueryVariables>;
export const CreateImageMutationDocument = gql`
    mutation CreateImageMutation($path: String!, $height: Int!, $width: Int!) {
  createImage(input: {image: {path: $path, width: $width, height: $height}}) {
    image {
      id
    }
  }
}
    ` as unknown as DocumentNode<CreateImageMutationMutation, CreateImageMutationMutationVariables>;
export const CreatePictureDocument = gql`
    mutation CreatePicture($image: BigInt!) {
  createPicture(input: {picture: {image: $image}}) {
    picture {
      img {
        height
        src
        srcSetJpeg
        srcSetWebp
        width
      }
      id
      rank
      allowOnHome
    }
  }
}
    ` as unknown as DocumentNode<CreatePictureMutation, CreatePictureMutationVariables>;
export const ReorderPicturesMutationDocument = gql`
    mutation ReorderPicturesMutation($reorders: [ReorderPicturesReorderInput]!) {
  reorderPictures(input: {reorders: $reorders}) {
    boolean
  }
}
    ` as unknown as DocumentNode<ReorderPicturesMutationMutation, ReorderPicturesMutationMutationVariables>;
export const SetPictureAllowOnHomeMutationDocument = gql`
    mutation SetPictureAllowOnHomeMutation($id: BigInt!, $input: Boolean!) {
  updatePicture(input: {patch: {allowOnHome: $input}, id: $id}) {
    picture {
      image
      id
      rank
      allowOnHome
      img {
        height
        src
        srcSetJpeg
        srcSetWebp
        width
      }
    }
  }
}
    ` as unknown as DocumentNode<SetPictureAllowOnHomeMutationMutation, SetPictureAllowOnHomeMutationMutationVariables>;