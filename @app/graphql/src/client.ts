/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
};

/** All input for the create `EventCategory` mutation. */
export type CreateEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventCategory` to be created by this mutation. */
  eventCategory: EventCategoryInput;
};

/** The output of our create `EventCategory` mutation. */
export type CreateEventCategoryPayload = {
  __typename?: 'CreateEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategory` that was created by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventCategory` mutation. */
export type CreateEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the create `EventCategoryTr` mutation. */
export type CreateEventCategoryTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventCategoryTr` to be created by this mutation. */
  eventCategoryTr: EventCategoryTrInput;
};

/** The output of our create `EventCategoryTr` mutation. */
export type CreateEventCategoryTrPayload = {
  __typename?: 'CreateEventCategoryTrPayload';
  /** Reads a single `EventCategory` that is related to this `EventCategoryTr`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategoryTr` that was created by this mutation. */
  eventCategoryTr: Maybe<EventCategoryTr>;
  /** An edge for our `EventCategoryTr`. May be used by Relay 1. */
  eventCategoryTrEdge: Maybe<EventCategoryTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventCategoryTr` mutation. */
export type CreateEventCategoryTrPayloadEventCategoryTrEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoryTrsOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /** Reads a single `EventCategory` that is related to this `Event`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the create `EventTemplate` mutation. */
export type CreateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTemplate` to be created by this mutation. */
  eventTemplate: EventTemplateInput;
};

/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayload = {
  __typename?: 'CreateEventTemplatePayload';
  /** Reads a single `EventCategory` that is related to this `EventTemplate`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was created by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTemplate` mutation. */
export type CreateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTemplateTr` to be created by this mutation. */
  eventTemplateTr: EventTemplateTrInput;
};

/** The output of our create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrPayload = {
  __typename?: 'CreateEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was created by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTemplateTr` mutation. */
export type CreateEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the create `EventTr` mutation. */
export type CreateEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EventTr` to be created by this mutation. */
  eventTr: EventTrInput;
};

/** The output of our create `EventTr` mutation. */
export type CreateEventTrPayload = {
  __typename?: 'CreateEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was created by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `EventTr` mutation. */
export type CreateEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Group` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the create `GroupTr` mutation. */
export type CreateGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GroupTr` to be created by this mutation. */
  groupTr: GroupTrInput;
};

/** The output of our create `GroupTr` mutation. */
export type CreateGroupTrPayload = {
  __typename?: 'CreateGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was created by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `GroupTr` mutation. */
export type CreateGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the create `Member` mutation. */
export type CreateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` to be created by this mutation. */
  member: MemberInput;
};

/** The output of our create `Member` mutation. */
export type CreateMemberPayload = {
  __typename?: 'CreateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was created by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Member` mutation. */
export type CreateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the create `PageTr` mutation. */
export type CreatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PageTr` to be created by this mutation. */
  pageTr: PageTrInput;
};

/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayload = {
  __typename?: 'CreatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was created by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `PageTr` mutation. */
export type CreatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
};

/** All input for the `deleteEventCategory` mutation. */
export type DeleteEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventCategory` mutation. */
export type DeleteEventCategoryPayload = {
  __typename?: 'DeleteEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventCategoryNodeId: Maybe<Scalars['ID']>;
  /** The `EventCategory` that was deleted by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventCategory` mutation. */
export type DeleteEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the `deleteEventCategoryTr` mutation. */
export type DeleteEventCategoryTrInput = {
  categoryId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
};

/** The output of our delete `EventCategoryTr` mutation. */
export type DeleteEventCategoryTrPayload = {
  __typename?: 'DeleteEventCategoryTrPayload';
  /** Reads a single `EventCategory` that is related to this `EventCategoryTr`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventCategoryTrNodeId: Maybe<Scalars['ID']>;
  /** The `EventCategoryTr` that was deleted by this mutation. */
  eventCategoryTr: Maybe<EventCategoryTr>;
  /** An edge for our `EventCategoryTr`. May be used by Relay 1. */
  eventCategoryTrEdge: Maybe<EventCategoryTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventCategoryTr` mutation. */
export type DeleteEventCategoryTrPayloadEventCategoryTrEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoryTrsOrderBy>>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /** Reads a single `EventCategory` that is related to this `Event`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventNodeId: Maybe<Scalars['ID']>;
  /** The `Event` that was deleted by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteEventTemplate` mutation. */
export type DeleteEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayload = {
  __typename?: 'DeleteEventTemplatePayload';
  /** Reads a single `EventCategory` that is related to this `EventTemplate`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTemplateNodeId: Maybe<Scalars['ID']>;
  /** The `EventTemplate` that was deleted by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTemplate` mutation. */
export type DeleteEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `deleteEventTemplateTr` mutation. */
export type DeleteEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `EventTemplateTr` mutation. */
export type DeleteEventTemplateTrPayload = {
  __typename?: 'DeleteEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTemplateTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was deleted by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTemplateTr` mutation. */
export type DeleteEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the `deleteEventTr` mutation. */
export type DeleteEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `EventTr` mutation. */
export type DeleteEventTrPayload = {
  __typename?: 'DeleteEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedEventTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was deleted by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `EventTr` mutation. */
export type DeleteEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteGroupTr` mutation. */
export type DeleteGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
};

/** The output of our delete `GroupTr` mutation. */
export type DeleteGroupTrPayload = {
  __typename?: 'DeleteGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedGroupTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was deleted by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `GroupTr` mutation. */
export type DeleteGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the `deleteMemberByUsername` mutation. */
export type DeleteMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};

/** All input for the `deleteMember` mutation. */
export type DeleteMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Member` mutation. */
export type DeleteMemberPayload = {
  __typename?: 'DeleteMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedMemberNodeId: Maybe<Scalars['ID']>;
  /** The `Member` that was deleted by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Member` mutation. */
export type DeleteMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `deletePage` mutation. */
export type DeletePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** The output of our delete `Page` mutation. */
export type DeletePagePayload = {
  __typename?: 'DeletePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageNodeId: Maybe<Scalars['ID']>;
  /** The `Page` that was deleted by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Page` mutation. */
export type DeletePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `deletePageTr` mutation. */
export type DeletePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayload = {
  __typename?: 'DeletePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  deletedPageTrNodeId: Maybe<Scalars['ID']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was deleted by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `PageTr` mutation. */
export type DeletePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

export type Event = {
  __typename?: 'Event';
  /** Reads a single `EventCategory` that is related to this `Event`. */
  category: Maybe<EventCategory>;
  categoryId: Scalars['BigInt'];
  endsAt: Scalars['Datetime'];
  id: Scalars['BigInt'];
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `EventTr`. */
  translations: EventTrsConnection;
};


export type EventTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** A connection to a list of `EventCategory` values. */
export type EventCategoriesConnection = {
  __typename?: 'EventCategoriesConnection';
  /** A list of edges which contains the `EventCategory` and cursor to aid in pagination. */
  edges: Array<EventCategoriesEdge>;
  /** A list of `EventCategory` objects. */
  nodes: Array<EventCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventCategory` edge in the connection. */
export type EventCategoriesEdge = {
  __typename?: 'EventCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventCategory` at the end of the edge. */
  node: EventCategory;
};

/** Methods to use when ordering `EventCategory`. */
export enum EventCategoriesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type EventCategory = {
  __typename?: 'EventCategory';
  /** Reads and enables pagination through a set of `EventTemplate`. */
  eventTemplatesByCategoryId: EventTemplatesConnection;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByCategoryId: EventsConnection;
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `EventCategoryTr`. */
  translations: EventCategoryTrsConnection;
};


export type EventCategoryEventTemplatesByCategoryIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateCondition>;
  filter?: Maybe<EventTemplateFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};


export type EventCategoryEventsByCategoryIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


export type EventCategoryTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCategoryTrCondition>;
  filter?: Maybe<EventCategoryTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventCategoryTrsOrderBy>>;
};

/**
 * A condition to be used against `EventCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventCategory` object types. All fields are combined with a logical ‘and.’ */
export type EventCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventCategoryFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventCategoryFilter>>;
};

/** An input for mutations affecting `EventCategory` */
export type EventCategoryInput = {
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `EventCategory`. Fields that are set will be updated. */
export type EventCategoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
};

export type EventCategoryTr = {
  __typename?: 'EventCategoryTr';
  /** Reads a single `EventCategory` that is related to this `EventCategoryTr`. */
  category: Maybe<EventCategory>;
  categoryId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
};

/**
 * A condition to be used against `EventCategoryTr` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventCategoryTrCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventCategoryTr` object types. All fields are combined with a logical ‘and.’ */
export type EventCategoryTrFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventCategoryTrFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Negates the expression. */
  not?: Maybe<EventCategoryTrFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventCategoryTrFilter>>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventCategoryTr` */
export type EventCategoryTrInput = {
  categoryId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
};

/** Represents an update to a `EventCategoryTr`. Fields that are set will be updated. */
export type EventCategoryTrPatch = {
  categoryId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventCategoryTr` values. */
export type EventCategoryTrsConnection = {
  __typename?: 'EventCategoryTrsConnection';
  /** A list of edges which contains the `EventCategoryTr` and cursor to aid in pagination. */
  edges: Array<EventCategoryTrsEdge>;
  /** A list of `EventCategoryTr` objects. */
  nodes: Array<EventCategoryTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventCategoryTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventCategoryTr` edge in the connection. */
export type EventCategoryTrsEdge = {
  __typename?: 'EventCategoryTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventCategoryTr` at the end of the edge. */
  node: EventCategoryTr;
};

/** Methods to use when ordering `EventCategoryTr`. */
export enum EventCategoryTrsOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `endsAt` field. */
  endsAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `special` field. */
  special?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startsAt` field. */
  startsAt?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `endsAt` field. */
  endsAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventFilter>>;
  /** Filter by the object’s `special` field. */
  special?: Maybe<BooleanFilter>;
  /** Filter by the object’s `startsAt` field. */
  startsAt?: Maybe<DatetimeFilter>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  categoryId: Scalars['BigInt'];
  endsAt: Scalars['Datetime'];
  id?: Maybe<Scalars['BigInt']>;
  special: Scalars['Boolean'];
  startsAt: Scalars['Datetime'];
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  categoryId?: Maybe<Scalars['BigInt']>;
  endsAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['BigInt']>;
  special?: Maybe<Scalars['Boolean']>;
  startsAt?: Maybe<Scalars['Datetime']>;
};

export type EventTemplate = {
  __typename?: 'EventTemplate';
  /** Reads a single `EventCategory` that is related to this `EventTemplate`. */
  category: Maybe<EventCategory>;
  categoryId: Scalars['BigInt'];
  id: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `EventTemplateTr`. */
  translations: EventTemplateTrsConnection;
};


export type EventTemplateTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateTrCondition>;
  filter?: Maybe<EventTemplateTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/**
 * A condition to be used against `EventTemplate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTemplateCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EventTemplate` object types. All fields are combined with a logical ‘and.’ */
export type EventTemplateFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventTemplateFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Negates the expression. */
  not?: Maybe<EventTemplateFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventTemplateFilter>>;
};

/** An input for mutations affecting `EventTemplate` */
export type EventTemplateInput = {
  categoryId: Scalars['BigInt'];
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `EventTemplate`. Fields that are set will be updated. */
export type EventTemplatePatch = {
  categoryId?: Maybe<Scalars['BigInt']>;
  id?: Maybe<Scalars['BigInt']>;
};

export type EventTemplateTr = {
  __typename?: 'EventTemplateTr';
  description: Scalars['String'];
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
  venue: Scalars['String'];
};

/**
 * A condition to be used against `EventTemplateTr` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EventTemplateTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventTemplateId` field. */
  eventTemplateId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTemplateTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTemplateTrFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventTemplateTrFilter>>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `eventTemplateId` field. */
  eventTemplateId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Negates the expression. */
  not?: Maybe<EventTemplateTrFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventTemplateTrFilter>>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTemplateTr` */
export type EventTemplateTrInput = {
  description: Scalars['String'];
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** Represents an update to a `EventTemplateTr`. Fields that are set will be updated. */
export type EventTemplateTrPatch = {
  description?: Maybe<Scalars['String']>;
  eventTemplateId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  title?: Maybe<Scalars['String']>;
  venue?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventTemplateTr` values. */
export type EventTemplateTrsConnection = {
  __typename?: 'EventTemplateTrsConnection';
  /** A list of edges which contains the `EventTemplateTr` and cursor to aid in pagination. */
  edges: Array<EventTemplateTrsEdge>;
  /** A list of `EventTemplateTr` objects. */
  nodes: Array<EventTemplateTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTemplateTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTemplateTr` edge in the connection. */
export type EventTemplateTrsEdge = {
  __typename?: 'EventTemplateTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTemplateTr` at the end of the edge. */
  node: EventTemplateTr;
};

/** Methods to use when ordering `EventTemplateTr`. */
export enum EventTemplateTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventTemplateIdAsc = 'EVENT_TEMPLATE_ID_ASC',
  EventTemplateIdDesc = 'EVENT_TEMPLATE_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

/** A connection to a list of `EventTemplate` values. */
export type EventTemplatesConnection = {
  __typename?: 'EventTemplatesConnection';
  /** A list of edges which contains the `EventTemplate` and cursor to aid in pagination. */
  edges: Array<EventTemplatesEdge>;
  /** A list of `EventTemplate` objects. */
  nodes: Array<EventTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTemplate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTemplate` edge in the connection. */
export type EventTemplatesEdge = {
  __typename?: 'EventTemplatesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTemplate` at the end of the edge. */
  node: EventTemplate;
};

/** Methods to use when ordering `EventTemplate`. */
export enum EventTemplatesOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type EventTr = {
  __typename?: 'EventTr';
  description: Scalars['String'];
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  slug: Scalars['String'];
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** A condition to be used against `EventTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `venue` field. */
  venue?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EventTr` object types. All fields are combined with a logical ‘and.’ */
export type EventTrFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EventTrFilter>>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Negates the expression. */
  not?: Maybe<EventTrFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EventTrFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `venue` field. */
  venue?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EventTr` */
export type EventTrInput = {
  description: Scalars['String'];
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  slug: Scalars['String'];
  title: Scalars['String'];
  venue: Scalars['String'];
};

/** Represents an update to a `EventTr`. Fields that are set will be updated. */
export type EventTrPatch = {
  description?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  venue?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EventTr` values. */
export type EventTrsConnection = {
  __typename?: 'EventTrsConnection';
  /** A list of edges which contains the `EventTr` and cursor to aid in pagination. */
  edges: Array<EventTrsEdge>;
  /** A list of `EventTr` objects. */
  nodes: Array<EventTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EventTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EventTr` edge in the connection. */
export type EventTrsEdge = {
  __typename?: 'EventTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `EventTr` at the end of the edge. */
  node: EventTr;
};

/** Methods to use when ordering `EventTr`. */
export enum EventTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  VenueAsc = 'VENUE_ASC',
  VenueDesc = 'VENUE_DESC'
}

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  EndsAtAsc = 'ENDS_AT_ASC',
  EndsAtDesc = 'ENDS_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SpecialAsc = 'SPECIAL_ASC',
  SpecialDesc = 'SPECIAL_DESC',
  StartsAtAsc = 'STARTS_AT_ASC',
  StartsAtDesc = 'STARTS_AT_DESC'
}

/** All input for the `formatArray` mutation. */
export type FormatArrayInput = {
  arr: Array<Maybe<Scalars['String']>>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  delim: Scalars['String'];
  formatStr: Scalars['String'];
};

/** The output of our `formatArray` mutation. */
export type FormatArrayPayload = {
  __typename?: 'FormatArrayPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  string: Maybe<Scalars['String']>;
};

/** All input for the `getColumns` mutation. */
export type GetColumnsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  excludeColumns: Array<Maybe<Scalars['String']>>;
  tableName: Scalars['String'];
};

/** The output of our `getColumns` mutation. */
export type GetColumnsPayload = {
  __typename?: 'GetColumnsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  strings: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type Group = {
  __typename?: 'Group';
  id: Scalars['BigInt'];
  image: ResponsiveImage;
  imageFile: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `GroupTr`. */
  translations: GroupTrsConnection;
};


export type GroupTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `imageFile` field. */
  imageFile?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `imageFile` field. */
  imageFile?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<GroupFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupFilter>>;
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  id?: Maybe<Scalars['BigInt']>;
  imageFile?: Maybe<Scalars['String']>;
};

export type GroupTr = {
  __typename?: 'GroupTr';
  description: Scalars['String'];
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
};

/** A condition to be used against `GroupTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupTrCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A filter to be used against `GroupTr` object types. All fields are combined with a logical ‘and.’ */
export type GroupTrFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupTrFilter>>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Negates the expression. */
  not?: Maybe<GroupTrFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupTrFilter>>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
};

/** An input for mutations affecting `GroupTr` */
export type GroupTrInput = {
  description: Scalars['String'];
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  title: Scalars['String'];
};

/** Represents an update to a `GroupTr`. Fields that are set will be updated. */
export type GroupTrPatch = {
  description?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['BigInt']>;
  languageCode?: Maybe<TrLanguage>;
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `GroupTr` values. */
export type GroupTrsConnection = {
  __typename?: 'GroupTrsConnection';
  /** A list of edges which contains the `GroupTr` and cursor to aid in pagination. */
  edges: Array<GroupTrsEdge>;
  /** A list of `GroupTr` objects. */
  nodes: Array<GroupTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GroupTr` edge in the connection. */
export type GroupTrsEdge = {
  __typename?: 'GroupTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `GroupTr` at the end of the edge. */
  node: GroupTr;
};

/** Methods to use when ordering `GroupTr`. */
export enum GroupTrsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageFileAsc = 'IMAGE_FILE_ASC',
  ImageFileDesc = 'IMAGE_FILE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Member = {
  __typename?: 'Member';
  id: Scalars['UUID'];
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Member` object types. All fields are combined with a logical ‘and.’ */
export type MemberFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MemberFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<MemberFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MemberFilter>>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
};

/** An input for mutations affecting `Member` */
export type MemberInput = {
  id?: Maybe<Scalars['UUID']>;
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  userRole: Scalars['String'];
  username: Scalars['String'];
};

/** Represents an update to a `Member`. Fields that are set will be updated. */
export type MemberPatch = {
  id?: Maybe<Scalars['UUID']>;
  isActive?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `Event`. */
  createEvent: Maybe<CreateEventPayload>;
  /** Creates a single `EventCategory`. */
  createEventCategory: Maybe<CreateEventCategoryPayload>;
  /** Creates a single `EventCategoryTr`. */
  createEventCategoryTr: Maybe<CreateEventCategoryTrPayload>;
  /** Creates a single `EventTemplate`. */
  createEventTemplate: Maybe<CreateEventTemplatePayload>;
  /** Creates a single `EventTemplateTr`. */
  createEventTemplateTr: Maybe<CreateEventTemplateTrPayload>;
  /** Creates a single `EventTr`. */
  createEventTr: Maybe<CreateEventTrPayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `GroupTr`. */
  createGroupTr: Maybe<CreateGroupTrPayload>;
  /** Creates a single `Member`. */
  createMember: Maybe<CreateMemberPayload>;
  /** Creates a single `Page`. */
  createPage: Maybe<CreatePagePayload>;
  /** Creates a single `PageTr`. */
  createPageTr: Maybe<CreatePageTrPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent: Maybe<DeleteEventPayload>;
  /** Deletes a single `EventCategory` using a unique key. */
  deleteEventCategory: Maybe<DeleteEventCategoryPayload>;
  /** Deletes a single `EventCategoryTr` using a unique key. */
  deleteEventCategoryTr: Maybe<DeleteEventCategoryTrPayload>;
  /** Deletes a single `EventTemplate` using a unique key. */
  deleteEventTemplate: Maybe<DeleteEventTemplatePayload>;
  /** Deletes a single `EventTemplateTr` using a unique key. */
  deleteEventTemplateTr: Maybe<DeleteEventTemplateTrPayload>;
  /** Deletes a single `EventTr` using a unique key. */
  deleteEventTr: Maybe<DeleteEventTrPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `GroupTr` using a unique key. */
  deleteGroupTr: Maybe<DeleteGroupTrPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMember: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMemberByUsername: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Page` using a unique key. */
  deletePage: Maybe<DeletePagePayload>;
  /** Deletes a single `PageTr` using a unique key. */
  deletePageTr: Maybe<DeletePageTrPayload>;
  formatArray: Maybe<FormatArrayPayload>;
  getColumns: Maybe<GetColumnsPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent: Maybe<UpdateEventPayload>;
  /** Updates a single `EventCategory` using a unique key and a patch. */
  updateEventCategory: Maybe<UpdateEventCategoryPayload>;
  /** Updates a single `EventCategoryTr` using a unique key and a patch. */
  updateEventCategoryTr: Maybe<UpdateEventCategoryTrPayload>;
  /** Updates a single `EventTemplate` using a unique key and a patch. */
  updateEventTemplate: Maybe<UpdateEventTemplatePayload>;
  /** Updates a single `EventTemplateTr` using a unique key and a patch. */
  updateEventTemplateTr: Maybe<UpdateEventTemplateTrPayload>;
  /** Updates a single `EventTr` using a unique key and a patch. */
  updateEventTr: Maybe<UpdateEventTrPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `GroupTr` using a unique key and a patch. */
  updateGroupTr: Maybe<UpdateGroupTrPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMember: Maybe<UpdateMemberPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMemberByUsername: Maybe<UpdateMemberPayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePage: Maybe<UpdatePagePayload>;
  /** Updates a single `PageTr` using a unique key and a patch. */
  updatePageTr: Maybe<UpdatePageTrPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventCategoryArgs = {
  input: CreateEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventCategoryTrArgs = {
  input: CreateEventCategoryTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTemplateArgs = {
  input: CreateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTemplateTrArgs = {
  input: CreateEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventTrArgs = {
  input: CreateEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupTrArgs = {
  input: CreateGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMemberArgs = {
  input: CreateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePageTrArgs = {
  input: CreatePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventCategoryArgs = {
  input: DeleteEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventCategoryTrArgs = {
  input: DeleteEventCategoryTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTemplateArgs = {
  input: DeleteEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTemplateTrArgs = {
  input: DeleteEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventTrArgs = {
  input: DeleteEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupTrArgs = {
  input: DeleteGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberArgs = {
  input: DeleteMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberByUsernameArgs = {
  input: DeleteMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageArgs = {
  input: DeletePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePageTrArgs = {
  input: DeletePageTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationFormatArrayArgs = {
  input: FormatArrayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGetColumnsArgs = {
  input: GetColumnsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventCategoryArgs = {
  input: UpdateEventCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventCategoryTrArgs = {
  input: UpdateEventCategoryTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTemplateArgs = {
  input: UpdateEventTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTemplateTrArgs = {
  input: UpdateEventTemplateTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventTrArgs = {
  input: UpdateEventTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupTrArgs = {
  input: UpdateGroupTrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberByUsernameArgs = {
  input: UpdateMemberByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePageTrArgs = {
  input: UpdatePageTrInput;
};

export type Page = {
  __typename?: 'Page';
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `PageTr`. */
  translations: PageTrsConnection;
};


export type PageTranslationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageCondition = {
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Page` object types. All fields are combined with a logical ‘and.’ */
export type PageFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PageFilter>>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<PageFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PageFilter>>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']>;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  name: Scalars['String'];
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  name?: Maybe<Scalars['String']>;
};

export type PageTr = {
  __typename?: 'PageTr';
  content: Scalars['String'];
  languageCode: TrLanguage;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  pageName: Scalars['String'];
};

/** A condition to be used against `PageTr` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PageTrCondition = {
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguage>;
  /** Checks for equality with the object’s `pageName` field. */
  pageName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PageTr` object types. All fields are combined with a logical ‘and.’ */
export type PageTrFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PageTrFilter>>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `languageCode` field. */
  languageCode?: Maybe<TrLanguageFilter>;
  /** Negates the expression. */
  not?: Maybe<PageTrFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PageTrFilter>>;
  /** Filter by the object’s `pageName` field. */
  pageName?: Maybe<StringFilter>;
};

/** An input for mutations affecting `PageTr` */
export type PageTrInput = {
  content: Scalars['String'];
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};

/** Represents an update to a `PageTr`. Fields that are set will be updated. */
export type PageTrPatch = {
  content?: Maybe<Scalars['String']>;
  languageCode?: Maybe<TrLanguage>;
  pageName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PageTr` values. */
export type PageTrsConnection = {
  __typename?: 'PageTrsConnection';
  /** A list of edges which contains the `PageTr` and cursor to aid in pagination. */
  edges: Array<PageTrsEdge>;
  /** A list of `PageTr` objects. */
  nodes: Array<PageTr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PageTr` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PageTr` edge in the connection. */
export type PageTrsEdge = {
  __typename?: 'PageTrsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `PageTr` at the end of the edge. */
  node: PageTr;
};

/** Methods to use when ordering `PageTr`. */
export enum PageTrsOrderBy {
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  LanguageCodeAsc = 'LANGUAGE_CODE_ASC',
  LanguageCodeDesc = 'LANGUAGE_CODE_DESC',
  Natural = 'NATURAL',
  PageNameAsc = 'PAGE_NAME_ASC',
  PageNameDesc = 'PAGE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  __typename?: 'PagesConnection';
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** A list of `Page` objects. */
  nodes: Array<Page>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  __typename?: 'PagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node: Page;
};

/** Methods to use when ordering `Page`. */
export enum PagesOrderBy {
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  arrayDiff: Maybe<Scalars['String']>;
  event: Maybe<Event>;
  /** Reads and enables pagination through a set of `EventCategory`. */
  eventCategories: Maybe<EventCategoriesConnection>;
  eventCategory: Maybe<EventCategory>;
  eventCategoryTr: Maybe<EventCategoryTr>;
  /** Reads and enables pagination through a set of `EventCategoryTr`. */
  eventCategoryTrs: Maybe<EventCategoryTrsConnection>;
  eventTemplate: Maybe<EventTemplate>;
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** Reads and enables pagination through a set of `EventTemplateTr`. */
  eventTemplateTrs: Maybe<EventTemplateTrsConnection>;
  /** Reads and enables pagination through a set of `EventTemplate`. */
  eventTemplates: Maybe<EventTemplatesConnection>;
  eventTr: Maybe<EventTr>;
  /** Reads and enables pagination through a set of `EventTr`. */
  eventTrs: Maybe<EventTrsConnection>;
  /** Reads and enables pagination through a set of `Event`. */
  events: Maybe<EventsConnection>;
  fRegexpEscape: Maybe<Scalars['String']>;
  group: Maybe<Group>;
  groupTr: Maybe<GroupTr>;
  /** Reads and enables pagination through a set of `GroupTr`. */
  groupTrs: Maybe<GroupTrsConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: Maybe<GroupsConnection>;
  member: Maybe<Member>;
  memberByUsername: Maybe<Member>;
  /** Reads and enables pagination through a set of `Member`. */
  members: Maybe<MembersConnection>;
  page: Maybe<Page>;
  pageTr: Maybe<PageTr>;
  /** Reads and enables pagination through a set of `PageTr`. */
  pageTrs: Maybe<PageTrsConnection>;
  /** Reads and enables pagination through a set of `Page`. */
  pages: Maybe<PagesConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  slugify: Maybe<Scalars['String']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryArrayDiffArgs = {
  array1: Scalars['String'];
  array2: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoriesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCategoryCondition>;
  filter?: Maybe<EventCategoryFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoryTrArgs = {
  categoryId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventCategoryTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCategoryTrCondition>;
  filter?: Maybe<EventCategoryTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventCategoryTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateTrArgs = {
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplateTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateTrCondition>;
  filter?: Maybe<EventTemplateTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTemplatesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTemplateCondition>;
  filter?: Maybe<EventTemplateFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrArgs = {
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventTrCondition>;
  filter?: Maybe<EventTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EventCondition>;
  filter?: Maybe<EventFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFRegexpEscapeArgs = {
  arg0: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrArgs = {
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupTrCondition>;
  filter?: Maybe<GroupTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberByUsernameArgs = {
  username: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MemberCondition>;
  filter?: Maybe<MemberFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPageArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrArgs = {
  languageCode: TrLanguage;
  pageName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPageTrsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageTrCondition>;
  filter?: Maybe<PageTrFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PageCondition>;
  filter?: Maybe<PageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySlugifyArgs = {
  t: Scalars['String'];
};

export type ResponsiveImage = {
  __typename?: 'ResponsiveImage';
  src: Scalars['String'];
  srcSetJpeg: Scalars['String'];
  srcSetWebp: Scalars['String'];
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
};

export enum TrLanguage {
  Da = 'DA',
  En = 'EN'
}

/** A filter to be used against TrLanguage fields. All fields are combined with a logical ‘and.’ */
export type TrLanguageFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TrLanguage>;
  /** Equal to the specified value. */
  equalTo?: Maybe<TrLanguage>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TrLanguage>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TrLanguage>;
  /** Included in the specified list. */
  in?: Maybe<Array<TrLanguage>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<TrLanguage>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TrLanguage>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TrLanguage>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TrLanguage>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TrLanguage>>;
};


/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['UUID']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['UUID']>>;
};

/** All input for the `updateEventCategory` mutation. */
export type UpdateEventCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventCategory` being updated. */
  patch: EventCategoryPatch;
};

/** The output of our update `EventCategory` mutation. */
export type UpdateEventCategoryPayload = {
  __typename?: 'UpdateEventCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategory` that was updated by this mutation. */
  eventCategory: Maybe<EventCategory>;
  /** An edge for our `EventCategory`. May be used by Relay 1. */
  eventCategoryEdge: Maybe<EventCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventCategory` mutation. */
export type UpdateEventCategoryPayloadEventCategoryEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoriesOrderBy>>;
};

/** All input for the `updateEventCategoryTr` mutation. */
export type UpdateEventCategoryTrInput = {
  categoryId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventCategoryTr` being updated. */
  patch: EventCategoryTrPatch;
};

/** The output of our update `EventCategoryTr` mutation. */
export type UpdateEventCategoryTrPayload = {
  __typename?: 'UpdateEventCategoryTrPayload';
  /** Reads a single `EventCategory` that is related to this `EventCategoryTr`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventCategoryTr` that was updated by this mutation. */
  eventCategoryTr: Maybe<EventCategoryTr>;
  /** An edge for our `EventCategoryTr`. May be used by Relay 1. */
  eventCategoryTrEdge: Maybe<EventCategoryTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventCategoryTr` mutation. */
export type UpdateEventCategoryTrPayloadEventCategoryTrEdgeArgs = {
  orderBy?: Maybe<Array<EventCategoryTrsOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /** Reads a single `EventCategory` that is related to this `Event`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: Maybe<Array<EventsOrderBy>>;
};

/** All input for the `updateEventTemplate` mutation. */
export type UpdateEventTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `EventTemplate` being updated. */
  patch: EventTemplatePatch;
};

/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayload = {
  __typename?: 'UpdateEventTemplatePayload';
  /** Reads a single `EventCategory` that is related to this `EventTemplate`. */
  category: Maybe<EventCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EventTemplate` that was updated by this mutation. */
  eventTemplate: Maybe<EventTemplate>;
  /** An edge for our `EventTemplate`. May be used by Relay 1. */
  eventTemplateEdge: Maybe<EventTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTemplate` mutation. */
export type UpdateEventTemplatePayloadEventTemplateEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplatesOrderBy>>;
};

/** All input for the `updateEventTemplateTr` mutation. */
export type UpdateEventTemplateTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventTemplateId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventTemplateTr` being updated. */
  patch: EventTemplateTrPatch;
};

/** The output of our update `EventTemplateTr` mutation. */
export type UpdateEventTemplateTrPayload = {
  __typename?: 'UpdateEventTemplateTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `EventTemplate` that is related to this `EventTemplateTr`. */
  eventTemplate: Maybe<EventTemplate>;
  /** The `EventTemplateTr` that was updated by this mutation. */
  eventTemplateTr: Maybe<EventTemplateTr>;
  /** An edge for our `EventTemplateTr`. May be used by Relay 1. */
  eventTemplateTrEdge: Maybe<EventTemplateTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTemplateTr` mutation. */
export type UpdateEventTemplateTrPayloadEventTemplateTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTemplateTrsOrderBy>>;
};

/** All input for the `updateEventTr` mutation. */
export type UpdateEventTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  eventId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `EventTr` being updated. */
  patch: EventTrPatch;
};

/** The output of our update `EventTr` mutation. */
export type UpdateEventTrPayload = {
  __typename?: 'UpdateEventTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Event` that is related to this `EventTr`. */
  event: Maybe<Event>;
  /** The `EventTr` that was updated by this mutation. */
  eventTr: Maybe<EventTr>;
  /** An edge for our `EventTr`. May be used by Relay 1. */
  eventTrEdge: Maybe<EventTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `EventTr` mutation. */
export type UpdateEventTrPayloadEventTrEdgeArgs = {
  orderBy?: Maybe<Array<EventTrsOrderBy>>;
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateGroupTr` mutation. */
export type UpdateGroupTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  languageCode: TrLanguage;
  /** An object where the defined keys will be set on the `GroupTr` being updated. */
  patch: GroupTrPatch;
};

/** The output of our update `GroupTr` mutation. */
export type UpdateGroupTrPayload = {
  __typename?: 'UpdateGroupTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupTr`. */
  group: Maybe<Group>;
  /** The `GroupTr` that was updated by this mutation. */
  groupTr: Maybe<GroupTr>;
  /** An edge for our `GroupTr`. May be used by Relay 1. */
  groupTrEdge: Maybe<GroupTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `GroupTr` mutation. */
export type UpdateGroupTrPayloadGroupTrEdgeArgs = {
  orderBy?: Maybe<Array<GroupTrsOrderBy>>;
};

/** All input for the `updateMemberByUsername` mutation. */
export type UpdateMemberByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
  username: Scalars['String'];
};

/** All input for the `updateMember` mutation. */
export type UpdateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
  /** An object where the defined keys will be set on the `Member` being updated. */
  patch: MemberPatch;
};

/** The output of our update `Member` mutation. */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Member` that was updated by this mutation. */
  member: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Member` mutation. */
export type UpdateMemberPayloadMemberEdgeArgs = {
  orderBy?: Maybe<Array<MembersOrderBy>>;
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  patch: PagePatch;
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page: Maybe<Page>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge: Maybe<PagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadPageEdgeArgs = {
  orderBy?: Maybe<Array<PagesOrderBy>>;
};

/** All input for the `updatePageTr` mutation. */
export type UpdatePageTrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  languageCode: TrLanguage;
  pageName: Scalars['String'];
  /** An object where the defined keys will be set on the `PageTr` being updated. */
  patch: PageTrPatch;
};

/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayload = {
  __typename?: 'UpdatePageTrPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Reads a single `Page` that is related to this `PageTr`. */
  pageByPageName: Maybe<Page>;
  /** The `PageTr` that was updated by this mutation. */
  pageTr: Maybe<PageTr>;
  /** An edge for our `PageTr`. May be used by Relay 1. */
  pageTrEdge: Maybe<PageTrsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `PageTr` mutation. */
export type UpdatePageTrPayloadPageTrEdgeArgs = {
  orderBy?: Maybe<Array<PageTrsOrderBy>>;
};

export type CalendarEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
  startsBefore?: Maybe<Scalars['Datetime']>;
}>;


export type CalendarEventsQueryQuery = (
  { __typename?: 'Query' }
  & { events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & EventFragment
    )> }
  )> }
);

export type EventFragment = (
  { __typename?: 'Event' }
  & Pick<Event, 'endsAt' | 'id' | 'startsAt' | 'categoryId' | 'special'>
  & { translations: (
    { __typename?: 'EventTrsConnection' }
    & { nodes: Array<(
      { __typename?: 'EventTr' }
      & Pick<EventTr, 'slug' | 'title' | 'languageCode' | 'description'>
    )> }
  ) }
);

export type HomeEventsQueryQueryVariables = Exact<{
  startsAfter?: Maybe<Scalars['Datetime']>;
}>;


export type HomeEventsQueryQuery = (
  { __typename?: 'Query' }
  & { specialEvents: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & EventFragment
    )> }
  )>, events: Maybe<(
    { __typename?: 'EventsConnection' }
    & { nodes: Array<(
      { __typename?: 'Event' }
      & EventFragment
    )> }
  )> }
);

export type HomeGroupsQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeGroupsQueryQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<(
    { __typename?: 'GroupsConnection' }
    & { nodes: Array<(
      { __typename?: 'Group' }
      & Pick<Group, 'id'>
      & { image: (
        { __typename?: 'ResponsiveImage' }
        & Pick<ResponsiveImage, 'src' | 'srcSetWebp' | 'srcSetJpeg'>
      ), translations: (
        { __typename?: 'GroupTrsConnection' }
        & { nodes: Array<(
          { __typename?: 'GroupTr' }
          & Pick<GroupTr, 'languageCode' | 'title' | 'description'>
        )> }
      ) }
    )> }
  )> }
);

export type PageQueryQueryVariables = Exact<{
  name?: Maybe<Scalars['String']>;
}>;


export type PageQueryQuery = (
  { __typename?: 'Query' }
  & { page: Maybe<(
    { __typename?: 'Page' }
    & { translations: (
      { __typename?: 'PageTrsConnection' }
      & { nodes: Array<(
        { __typename?: 'PageTr' }
        & Pick<PageTr, 'content' | 'languageCode'>
      )> }
    ) }
  )> }
);

export const EventFragmentDoc = gql`
    fragment event on Event {
  translations {
    nodes {
      slug
      title
      languageCode
      description
    }
  }
  endsAt
  id
  startsAt
  categoryId
  special
}
    ` as unknown as DocumentNode<EventFragment, unknown>;
export const CalendarEventsQueryDocument = gql`
    query CalendarEventsQuery($startsAfter: Datetime, $startsBefore: Datetime) {
  events(
    filter: {startsAt: {greaterThan: $startsAfter, lessThan: $startsBefore}}
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...event
    }
  }
}
    ${EventFragmentDoc}` as unknown as DocumentNode<CalendarEventsQueryQuery, CalendarEventsQueryQueryVariables>;
export const HomeEventsQueryDocument = gql`
    query HomeEventsQuery($startsAfter: Datetime) {
  specialEvents: events(
    filter: {special: {equalTo: true}, startsAt: {greaterThan: $startsAfter}}
    first: 1
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...event
    }
  }
  events(
    filter: {special: {equalTo: false}, startsAt: {greaterThan: $startsAfter}}
    first: 5
    orderBy: STARTS_AT_ASC
  ) {
    nodes {
      ...event
    }
  }
}
    ${EventFragmentDoc}` as unknown as DocumentNode<HomeEventsQueryQuery, HomeEventsQueryQueryVariables>;
export const HomeGroupsQueryDocument = gql`
    query HomeGroupsQuery {
  groups {
    nodes {
      id
      image {
        src
        srcSetWebp
        srcSetJpeg
      }
      translations {
        nodes {
          languageCode
          title
          description
        }
      }
    }
  }
}
    ` as unknown as DocumentNode<HomeGroupsQueryQuery, HomeGroupsQueryQueryVariables>;
export const PageQueryDocument = gql`
    query PageQuery($name: String = "") {
  page(name: $name) {
    translations {
      nodes {
        content
        languageCode
      }
    }
  }
}
    ` as unknown as DocumentNode<PageQueryQuery, PageQueryQueryVariables>;